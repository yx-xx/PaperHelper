=== PDF文件: Diffeomorphic Obstacle Avoidance for Contractive Dynamical Systems via Implicit Representations.pdf ===
=== 时间: 2025-07-22 16:15:41.028071 ===

请你只输出如下JSON，所有字段都必须有，且每个“关键词”字段只允许输出一个最核心的最有代表性的中文关键词，要中文关键词，如果是英文关键词就尝试翻译成中文（不能是英文，不能是多个，不能有逗号、分号、空格），否则视为不合格。不要输出任何解释或正文，只输出JSON。
{
  "论文标题": "",
  "研究主题关键词": "",
  "应用场景关键词": "",
  "主要方法关键词": "",
  "创新点关键词": "",
  "主要结论关键词": ""
}
内容：Diffeomorphic Obstacle Avoidance for Contractive
Dynamical Systems via Implicit Representations
Ken-Joel Simmoteit
Karlsruhe Institute of Technology
Ken-Joel.Simmoteitstudent.kit.edu
Philipp Schillinger
Bosch Center for Artificial Intelligence
Philipp.Schillingerde.bosch.com
Leonel Rozo
Bosch Center for Artificial Intelligence
Leonel.Rozode.bosch.com
AbstractEnsuring safety and robustness of robot skills is
becoming crucial as robots are required to perform increasingly
complex and dynamic tasks. The former is essential when
performing tasks in cluttered environments, while the latter is
relevant to overcome unseen task situations. This paper addresses
the challenge of ensuring both safety and robustness in dynamic
robot skills learned from demonstrations. Specifically, we build
on neural contractive dynamical systems to provide robust
extrapolation of the learned skills, while designing a full-body
obstacle avoidance strategy that preserves contraction stability
via diffeomorphic transforms. This is particularly crucial in
complex environments where implicit scene representations, such
as Signed Distance Fields (SDFs), are necessary. To this end, our
framework called Signed Distance Field Diffeomorphic Trans-
contraction-preserving obstacle avoidance. We thoroughly evalu-
ate our framework on synthetic datasets and several real-world
robotic tasks in a kitchen environment. Our results show that our
approach locally adapts the learned contractive vector field while
staying close to the learned dynamics and without introducing
highly-curved motion paths, thus outperforming several state-of-
the-art methods.
I. INTRODUCTION
Teaching robots skills has been a key challenge in robotics
research for over four decades . The dominant paradigm
involves learning robotic skills through expert examples,
commonly referred to as Learning from Demonstration
enabling
complex motion skills, LfD has led to numerous promising
applications
flexible
manufacturing [16, 59], household environments [51, 69],
human-robot collaboration [31, 57, 58], and robot-assisted
minimally invasive surgery , among many others.
For safe operation in human-centric and dynamic settings,
learned skills must be stable and reliable, avoiding unex-
pected movements under unseen situations such as different
task conditions or external perturbations. This highlights the
importance of stable LfD skills . Early efforts to ensure
stability in LfD focused on asymptotic stability criteria, of-
ten leveraging Lyapunov stability [12, 25, 51, 68]. While
Lyapunov stability primarily ensures asymptotic point-wise
relevant trajectories. To address this limitation, researchers
have conceptualized a more general stability criterion, namely
the contraction property of dynamical systems, which guar-
Neuronal Implicit
Distance Function
Neural Contractive
Dynamical System
Signed Distance
Field Diffeomorphic
Transform
Barrier Function
Infinitesimal
Generator
Joint Impedance
Figure 1: Overview of the proposed Signed Distance Field Diffeo-
morphic Transform: (1) A neural contractive dynamical system; (2)
A learned implicit distance function; (3) A barrier function, and (4)
a contraction-preserving diffeomorphic transform.
antees exponential convergence to a trajectory [38, 67]. This
concept has been recently leveraged in LfD frameworks, where
a robot skill, represented by a first-order dynamical system, is
endowed with a contractive behavior [4, 9, 54, 62].
In addition to stability, ensuring safety is paramount. This
often demands integrating obstacle avoidance into robot skills
while still providing stability guarantees. In the context of
contractive systems, Huber et al.  introduced the Mod-
ulation Matrix (MM) method to preserve contraction stability
during obstacle avoidance. Subsequently, Beik-Mohammadi
et al.  applied this approach to neural contractive dynamical
systems (NCDS), enabling stable collision-free motion in
the robots task space. Despite these advances, articulated
robotic arms require whole-body obstacle avoidance. While
traditional methods like artificial potential fields  and
recent approaches like Diffeomorphic Transforms (DT) ,
tackle this problem via robust joint-space obstacle avoidance
solutions that account for asymptotic stability, they do not
consider contraction stability guarantees. Therefore, preserving
contraction during whole-body obstacle avoidance remains
largely unexplored, posing a key challenge for robot motion
When considering cluttered and dynamic environments,
such as household settings, conventional obstacle representa-
tions using simple geometric primitives are insufficient [4, 19],
as they rely on coarse approximations and may not be easily
integrated with neural architectures. Instead, a differentiable
implicit distance representation is more advantageous as it
facilitates a fine-grained, real-time, and resource-efficient so-
network architectures. This has led to the rise of Signed
Distance Fields (SDF)s [15, 22, 45, 47], which have recently
been leveraged to learn articulated robot surfaces [11, 30, 36].
In these approaches, the SDF is a function of the robots joint
configuration space. Still, integrating implicit representations
with contraction-preserving obstacle avoidance remains an
open problem. To bride this gap, we propose to combine
the robustness of contraction stability with the precision of
implicit representations for efficient and safe whole-body
obstacle avoidance.
Signed Distance Field Diffeomorphic Transform (SDT),
for contraction-preserving obstacle avoidance based on an
implicit scene representation. The key contributions of this
work are:
1) Contraction-Preserving
Implicit
Obstacle
contraction-preserving obstacle avoidance in contrac-
tive dynamical systems by leveraging DT, SDF tech-
finitesimal generator derived from the robots implicit
representation and regulate it using barrier functions.
a flow that reshapes the contractive dynamics, either
differential
coordinate
applying a standard coordinate change via a pullback.
2) Obstacle Avoidance Metrics: We introduce a set of
quantitative metrics to assess obstacle avoidance per-
misalignment of the modulated contractive motion.
3) Experiments:
extensively
evaluated
framework
on two real-world tasks in a kitchen environment:
(1) EMPTYING A DISHWASHER; and (2) OPENING
A DISHWASHER. We also provide a comprehensive
comparison among various SDF methods and obstacle
avoidance approaches including Modulation Matrix
(MM), DT and artificial potential functions.
II. RELATED WORK
A. Learning Contractive Dynamical Systems
The use of contractive guarantees in learned dynamical
systems is a growing trend in robot motion skill learning. In
model via three methods: (i) As a regularizer or constraint on
the main skill learning objective [54, 55]; (ii) As a contraction
metric designed to stabilize a non-contractive skill [65, 66];
and (iii) By learning a skill model that is contractive by
design [1, 4, 23, 5]. The latter strategy is the one we follow in
our framework as it provides stronger theoretical and practical
guarantees. We review this set of works in more detail next.
Beik-Mohammadi et al.  introduced Neural Contractive
Dynamical System (NCDS), which inherently embeds the con-
traction property within a Neural Network (NN), thus avoiding
regularizers or a separate model for learning a contraction
metric. NCDS was later extended with regularizers controlling
the systems contraction rate, in addition to conditioning on
task variables and providing contraction-preserving obstacle
avoidance via pullback Riemannian metrics . Similarly,
Jaffe et al.  presented an inherently contractive model,
which leverages diffeomorphisms between the data space
and a latent space to provide global contraction guarantees.
Another approach is followed by Abyaneh et al. , who
propose learning an inherent contractive dynamical system
via recurrent equilibrium networks and coupling layers. We
build upon previous work to learn a contractive dynamical
system via NCDS. However, our approach can be seamlessly
integrated with any contractive dynamical system. Thereby, we
address the contraction-preserving obstacle avoidance prob-
except in [4, 18].
B. Stability-Preserving Obstacle Avoidance
Applying reactive obstacle avoidance in LfD settings re-
quires careful consideration to ensure safe and robust robot
stable dynamical systems. To address this, Khansari-Zadeh and
Billard  enhanced the Harmonic Potential Function ,
which uses potential flows from fluid mechanics for obstacle
tems maintain stability via an MM. Later, Huber et al.
demonstrated that this approach can also preserve contraction
et al.  primarily relied on simple geometric primitives
for obstacle avoidance, Fourie et al.  employed learned
obstacle representations of the entire robot configuration space
combined with MM. Their work, conducted in parallel to our
contraction stability guarantees.
Building on prior work in learning stable dynamical systems
via diffeomorphisms [44, 51, 68, 70], Zhi et al.  introduced
the DT method, which defines an obstacle-avoidance diffeo-
morphism via a flow field. This diffeomorphism transforms
the learned dynamics while providing asymptotically-stable
obstacle avoidance. Importantly, the DT method also accounts
for joint-space stable skills using the Moore-Penrose inverse
and the robots forward kinematics. This work, however,
shared a limitation with some of the foregoing approaches:
A focus on asymptotic stability rather than the more general
contraction property. In summary, whole-body obstacle avoid-
ance methods that preserve contraction, especially in complex
remains unresolved.
C. Implicit Robot Representations
Capturing the robots spatial structure is essential for
enabling
effective
obstacle
preventing
implicit representations provide a powerful way to model a
robots shape and volume. For example, SDFs provide an
representation. Studies by Li et al.  and Chen et al.
demonstrate that SDFs offer significant advantages over
geometric primitives by providing a higher level of detail,
facilitating precise interaction.
The use of implicit representations for articulated kinematic
chains is particularly challenging as the configuration of the
robots structure in the workspace varies as a function of the
robot joint position. In this case, each robot link can be mod-
eled by separate SDFs using architectures such as NNs
and Bernstein polynomial basis functions (BP) , or the
entire robot body can be represented using a single model ,
all of which yielding smooth surfaces. Notably, Li et al.
observe that learning the Euclidean distance between the
robot surface and a workspace query point is highly non-
linear in configuration space. To mitigate this, they propose
computing the distance in configuration space, leading to the
Configuration Space Distance Fields (CDF) method. While Li
et al.  and Marticorena et al.  made obstacle avoidance
for point-to-point motion possible using SDFs and a QP solver,
no existing approaches, to the best of our knowledge, perform
contraction-preserving obstacle avoidance with SDFs.
III. BACKGROUND
A. Contraction Stability
We are interested in learning contractive robot motion
certificate for robust generalization. Intuitively, contraction
stability studies the evolution of two trajectories of a dynam-
ical system given different initial conditions . In other
its initial conditions rapidly, with the distance between any
two trajectories decreasing exponentially over time. Formally,
consider two trajectories i and j generated by a dynamical
system of the form xt  f(xt), where xt RD is the system
placement x  j i, the squared distance between the tra-
jectories corresponds to xx . Contraction theory cares
about the evolution of this distance, i.e., its rate of change,
dt(xx)  2x x  2xJf(x)x,
where  x  Jf(x)x, with Jf(x)  fx. Lohmiller and
Slotine  show that a dynamical system exhibits contraction
if the largest eigenvalue max of the symmetric part of its
Jacobian is uniformly and strictly negative. Therefore,
dt(xx) 2maxxx xx0et,
displacement
decreases
exponentially to zero with contraction rate  .
Definition 1 (Contraction stability ). A dynamical system
xt  f(xt) is contractive if its Jacobian Jf  f
x is uniformly
negative definite for all x Rn and at all times t 0. This
means that,
Definition 1 can be generalized to account for a more
general distance definition, namely xG(x)x, where G(x)
is a Riemannian metric [32, 61]. This also allows us to analyze
the contractive behavior of a dynamical system under a coor-
dinate change via a smooth diffeomorphism y  (x). The
corresponding differential change in coordinates is given by
y  Jx, where J is the Jacobian of the diffeomorphism
. Manchester and Slotine  demonstrated that contraction
is invariant under such coordinate changes.
Theorem 1 (Invariance under coordinate change ). If
Definition 1 is satisfied for a dynamical system, then it is
preserved under the following transformations:
1) Affine feedback transformations u(x, v)  a(x)
B(x)v, with B(x) being a smooth nonsingular n  n
matrix function;
2) Differential coordinate changes y  J(x)x, where
J(x) is a nonsingular matrix for all x, and induces
a new contraction metric,
Gy(x) : J(x)G(x)J(x);
3) Coordinate changes y  (x), where  is a diffeo-
Given a contraction metric as stated in Theorem 1, we
can also determine whether a given system is contractive by
following the results in .
(Contraction
conditions
that a uniformly positive definite matrix G(x, t)
J(x)J(x) 0 exists, x, t, where J(x) defines a
smooth coordinate transformation of the differential x, i.e.,
y  J(x)x. The following equivalent condition holds
for  R>0 and x, t,
then all solution trajectories of the system converge ex-
ponentially fast to a single trajectory, irrespective of their
initial conditions, with an exponential convergence (con-
traction) rate .
B. Flow-based Diffeomorphisms
As contraction is preserved under a change of coordinates,
we leverage this to design obstacle-avoidance behaviors based
on diffeomorphic mappings, which we revise next. A diffeo-
smooth inverse, thereby providing a coordinate transformation
between two differentiable manifolds Y and X. According
to Lee [33, Theorem 9.12], any such diffeomorphism can be
realized as a flow generated by an infinitesimal generator V,
often represented as a vector field on a smooth manifold.
field and the flow  : R  Rd Rd be defined by,
(t, y)  y
V((u, y)) du  x.
This flow (t, y) provides the position x at time t of a
trajectory starting at y when t  0. For each fixed time t, this
flow defines a diffeomorphism : Y X by (y) : (t, y).
inverse can be computed by reversing the direction of time,
(t, x)  x
V((u, x)) du  y.
Note that this flow-based diffeomorphism (y) : (t, y)
maps the initial point y Y to the point x  (t, y) X.
assigns a tangent vector in TxX to each point x X, we can
use  to pullback f to a vector field on Y. Specifically, let
J be the Jacobian of , then the pullback of f via  is,
thereby transforming tangent vectors on X to corresponding
tangent vectors on Y .
C. Signed Distance Fields (SDFs)
Representing objects as meshes or point clouds is often
inefficient due to high memory requirements and redundant
information . Moreover, these discrete representations lack
smoothness and differentiability as they approximate surfaces
with sampled points or polygons. To overcome these lim-
representation. An SDF defined by SDF : Rd R, encodes
the objects surface through the minimum distance dmin from
a point x Rd to the surface using a smooth function .
Three regions can be identified: Free space Hf  {x Rd
SDF(x) > 0}, surface boundary Hs  {x Rd  SDF(x)
0}, and interior Hi  {x Rd  SDF(x) < 0} (see Fig. 2 for
an illustration).
Note that this approach decouples spatial resolution from
memory usage, enabling high-resolution reconstructions with
fast inference . Park et al.  propose using a Multilayer
Perceptron (MLP) to model the SDF, offering a lightweight
and efficient model. Additionally, piecewise polynomial rep-
resentations enable continuous surface modeling . Maric
et al.  extend this by employing BP basis functions which
enables smooth surfaces that can be incrementally refined.
Figure 2: Illustration of a
2D SDF: Contour lines of
an star-shaped SDF with
the distance SDF to the
obstacle surface, depicted
as a solid red line.
IV. CONTRACTION PRESERVING OBSTACLE AVOIDANCE
Here we introduce our contraction-preserving obstacle
avoidance method. First, we explain the contractive dynamical
system used in this paper. Later, we describe the contraction-
preserving obstacle avoidance method.
A. Learned Contractive Dynamical System
Consider a contractive dynamical system x  fNCDS(x),
where x represents the first-order time derivative of the system
state x. From Theorem 2, we know that if the symmetric part
of the system dynamics Jacobian JfNCDS is negative definite,
our dynamics is contractive. Beik-Mohammadi et al.  pro-
pose directly learning this Jacobian to intrinsically embed the
contraction property into fNCDS. Specifically, the Jacobian is
modeled with parameters  as,
JfNCDS(x)  (J(x)J(x)  ),
where J(x): RD RD represents the square root of the
> 0 guarantees that the eigenvalues are bounded by  .
Given the negative-definite Jacobian (9), the contractive dy-
namics is obtained via the calculus for line integrals ,
x  fNCDS(x)
c(x, t, x0)
c(x, t, x0)dt,
c(x, t, x0)  (1 t)x0  tx,
c(x, t, x0)  x x0,
and x0 is the initial system state . The velocity xt is
computed using a numerical integral solver given xt [4, 10].
When learning robot skills via NCDS, we have two options:
Learning the NCDS in joint space C or instead, encoding
the skill in task space X. In the latter case, NCDS uses Lie
groups to represent the end-effector orientation in SO(3) ,
and employs its Lie algebra so(3) to obtain skew-symmetric
matrices w so(3) . The mapping between SO(3) and
so(3) is defined via the exponential and the logarithmic map.
To train a NCDS model, the loss function minimizes the
average reconstruction error between the true next state xt1
and the predicted next state xt1  xt  xt1 ,
xt1 (xt  xt1)2.
Demonstrations
NCDS Trajectory
Figure 3:
Exemplary
NCDS model of a skill
demonstrated
trajectories
LASA dataset in black
integrated
motion over the NCDS
model in blue. The gray
represent
NCDS vector field.
Algorithm 1: NCDS Training in Joint Space
where n [1, N], t [1, Tn], and
initial parameters , initial regularizer
learned regularizer
1 while not converged do
for each demonstration n N do
for each time step t Tn do
Calculate JfNCDS of the NCDS with Eq. (9)
Define the contractive dynamics fNCDS with
Train the Jacobian network by solving:
,  argmin, (LJac  L  noiseLnoise)
In addition, a state-independent regularizer is added to opti-
mize the eigenvalue bound   [1,    , D] as follows ,
To enhance the local contraction properties of NCDS, we
propose an additional noise-injected reconstruction loss,
Lnoise  1
which acts orthogonally to the direction of motion x, with
xt N(xt, xt), representing noise injected in the di-
rections perpendicular to the movement. Our regularizer en-
courages NCDS to be robust against orthogonal perturbations,
thereby implicitly improving its local contractive behavior. The
total loss is L  LJac  L  noiseLnoise, with  and noise
being weights balancing the losses influence. NCDS training
is summarized in Algorithm 1. Additionally, Fig. 3 illustrates
a vector field learned by NCDS.
B. SDF-based Diffeomorphic Transform
Our obstacle avoidance method consists of two compo-
contraction-preserving transformation of a contractive vector
field fc. The latter can be: (1) A learned joint-space NCDS
RDF(x, q)
Figure 4: Illustration
showing the contour
lines of the robots
SDF for a Franka-
Emika Panda robot
grasping a plate. The
contours
indicate
the distance RDF to
the robots surface.
The inner gray mesh
robot surface R.
fNCDS(q); (2) A learned task-space NCDS fNCDS(x) mapped
to joint space; and (3) Any differentiable contractive dynamical
system in joint space. Next, we describe the implicit repre-
sentation of the robot surface, which provides the basis for
deriving the infinitesimal generator for obstacle avoidance.
1) Implicit Robot Representations: To achieve obstacle
the scene surface S and the robot surface R. Therefore we
start by learning an implicit representation of dmin. There are
two ways to achieve this: (1) A learned SDF of the robot
and; (2) A learned SDF of the scene. To learn a SDF for
the scene, we refer the reader to the established approaches
in [15, 45, 47]. On the other hand, the distance w.r.t the robot
surface can be defined by dmin  RDF(x, q), given a query
point x and the robot state q C [11, 30, 36]. This implicit
robot representation is called Robot Signed Distance Fields
(RDF). We follow the approach from Li et al.  and define
the RDF as,
RDF  min(r
K links in the robot base frame r. Thereby, each link is
transformed via the robots kinematic chain rTk(q) SE(3)
from the frame of the k-th link to the base frame, resulting
. Given the SDF o
(e.g., a grasped object) and its corresponding transformation
rTo(q) SE(3) to the robot base frame, we can easily extend
the RDF by adding the transformed ro to the min operation
in Equation (15). We choose BP to learn the SDF r
k of each
link k as it provides a particularly smooth surface. However,
any other SDF method can be used. An exemplary learned
RDF with a grasped plate is shown in Fig. 4.
distances rather than Euclidean point-to-surface distances,
leading to the CDF with corresponding implicit distance
function CDF. The CDF measures the distance in radians,
corresponding to the movement of joint angles towards the
zero-level configuration set q, resulting in ,
CDF(x, q)  min
CDF solves the inverse kinematics problem in a single step by
updating the current robot joint configuration along the CDF
Figure 5: Vector field
shaped SDF function
function
binv(x, q).
represent the barriers
magnitude.
solid red line shows
object and the dashed
grey line the safety
threshold tsave.
gradient toward the zero-level configuration set qvia,
q q CDF(x, q)qCDF(x, q).
CDF with an objects SDF, such as that of a grasped object, is
not as straightforward as in the RDF framework. Accomplish-
ing this would require training a new model or incorporating
additional conditioning into the existing model. In this work,
both RDF and CDF are employed and compared. In the
implicit distance function between the scene and the robot.
When referring specifically to the robots implicit distance
the implicit distance function of the scene.
2) Implicit Infinitesimal Generator: For obstacle avoidance,
the gradient qSDF determines how the robot joints should
move away from obstacles. Thus, this gradient acts as an
infinitesimal generator V. To ensure strict collision avoidance,
we use an inverse barrier function binv(x, q), similarly to .
This barrier is defined as follows,
binv(x, q)
SDF(x, q),
which is combined with the gradient, leading to the infinitesi-
mal generator V  binvqSDF. As SDF 0, then binv ,
ensuring collision avoidance. When SDF , then binv
qSDF. The introduction of this barrier function is motivated
by the fact that SDFs are often learned via the Eikonal loss,
enforcing xSDF(x, q) 1 . Thus, gradients remain
non-negligible even far away from the obstacles. Figure 5
illustrates the resulting vector field for a geometric primitive
following the aforementioned approach.
We can make the barrier function more general by adding
tunable parameters like a safety threshold tsave and a scaling
factor sgrad as follows,
binv(x, q)
SDF (x, q) tsave
at weighting movements towards and tangential to the obstacle
while ignoring those away from it, using the dot product
qNCDS  qSDF. To do so, we need to distinguish whether
the SDF of the scene S or of the robot R is used, since
the corresponding velocity fields and gradient direction may
differ. Specifically, if R is employed, then the gradient of
R and fc point in the same direction when moving towards
the obstacle and point in opposite directions when moving
away from it. If S is used, this phenomenon is the opposite.
For the implicit distance function of the robot and the scene,
swept-augmented barriers are defined as,
qNCDS  qR(x, q)
qNCDS qR(x, q)
qNCDS  qS(x, q)
qNCDS qS(x, q)
Although the foregoing barrier functions can be used inde-
barrier functions (18) and (20) or (21) by simply defining
b(x, q)  binv(x, q)bswept(x, q). Given the barrier function
b(x, q), the infinitesimal generator results in,
V(x, q)  b(x, q)qSDF(x, q).
3) Contraction-Preserving Differential Coordinate Change:
Given the infinitesimal generator V (22) obtained from the
SDF introduced in Section IV-B2, we know the joint directions
that locally maximize obstacle avoidance. Directly forcing the
robot away from the obstacle via,
q  fc(q)  fc(q) b(x, q)qSDF(x, q),
as proposed by Ravichandar and Dani , could violate
the contraction conditions of Theorem 2. This is because the
b(x, q)qSDF(x, q) term is not guaranteed to be negative
To achieve obstacle avoidance without breaking contraction
the obstacle by defining a mapping to a new obstacle-free
manifold Y that preserves contraction. To do this, we lever-
age Theorem 1, which tells us that contraction is preserved
under coordinate transformations or diffeomorphisms. Thus,
we cast the contraction-preserving obstacle avoidance problem
as finding a diffeomorphism that reshapes our contractive
dynamical system fc around the obstacle as a function of the
gradient of its implicit representation qSDF. As explained
in Section III-B, a diffeomorphism  can be designed from
a flow. If such a flow is differentiable, it is thus a valid
diffeomorphism.
We propose to leverage the flow generated by the infinites-
imal generator (22). Specifically, using the flow : Y C
as defined by Equation (6), we transform the obstacle-free
manifold y Y into the configuration space q C as follows,
Given the diffeomorphism (24), we can carry out a differ-
ential coordinate change,
using the Jacobian of the flow J. We refer to this transforma-
tion as Signed Distance Field Differential Coordinate Change
(SDDC). Based on Theorem 1, which states that contraction
is preserved under differential coordinate transformations, we
conclude that the transformed system fSDDC is contractive.
This therefore ensures that the robot can successfully avoid
obstacles while preserving the stability of the underlying skill.
4) Contraction-Preserving Diffeomorphic Transform:
Equation (26), we consider only the differential coordinate
under the diffeomorphism . However, to fully account for
geometric properties (e.g., lengths, distances, and angles), we
must consider the Riemannian metric of the obstacle-avoiding
manifold Y induced by  . By applying the diffeomor-
lently be described on the obstacle-avoiding manifold Y via,
y  fSDC(x, y)  J(y)1fc((x, y)).
where J denotes the Jacobian of . We refer to this
transformed dynamical system as Signed Distance Field
Coordinate Change (SDC). This coordinate change also
induces the Riemannian metric G
characterizes the local geometry on Y and corresponds to the
contraction metric. A proof of this equivalence is provided in
Appendix B4. To show that contraction is invariant under a
change of coordinates we can use Theorem 1. Consequently,
the proposed SDC preserves the contraction property. We
illustrate
contraction-preserving
obstacle
avoidance
methods SDDC and SDC using a toy example in Fig. 6a.
This example shows that, given an obstacle, the original
vector field fc from Fig. 3 is reshaped around the obstacle
by the SDDC and SDC, thus avoiding it successfully.
5) Enhancing Obstacle Avoidance with a Friction Term:
In the following, we introduce an extension to the proposed
obstacle avoidance methods. To avoid notational clutter, we
represent the vector field modulated by both the SDDC (26)
and SDC (27) collectively as fm. As observed in Fig. 6a,
the modulated velocity profile of fm may deviate significantly
from the original velocity profile learned by the NCDS skill.
To address this, we introduce a friction term aimed at preserv-
ing the velocity profile of the underlying contractive vector
field fc. Interestingly, this friction term can also be employed
to reduce the velocity near obstacles and to damp fluctuations
caused by discontinuities in the learned SDF. Inspired by ,
Algorithm 2: Modulated Robot Skill Execution
: Learned NCDS fNCDS,, learned SDF R,
1 while t N do
Sample point cloud {si}M
i1 S from the scene
Read robot joint and task state qt C, xt X
Find nearest point sto robot surface such that
R(s, q)  min{si}M
i1 R(si, q)
Solve the ODE from Equation (24) (x, qt)
Solve ODE from Equation (10) yNCDS,t
Modulate yNCDS,t via Equation (26) or (27) yt
Integrate modulated joint velocity yt yt1
Send yt1 to the robots joint impedance controller
our friction term is defined as,
fm(x, y)fm(x, y).
When f  1, the resulting dynamics adapts the velocity
magnitude to the underlying learned vector field fc, but keeps
the modulated direction from fm. Note that f  1 must not
be chosen for SDDC, because it just guarantees strict collision
avoidance at velocity level. If we enforce the SDDC to keep
the underlying velocity, it could potentially force the system
to penetrate the obstacle.
To slow down near obstacles, we design nf as follows,
(1  fSDF(x, y))2 ,
with hyperparameter f. The resulting vector field under
this friction term is depicted in Fig. 6c. Since
fSDC(x,y)
is strictly positive and f > 0, they induce no directional
changes. According to Theorem 1, contraction is preserved
under affine transformations, consequently the friction (28)
does not compromise the contraction guarantees.
6) Modulated Skill Execution: Finally, trajectories can be
integrated along fm, defined by the Equations (26) or (27).
avoiding space via SDC (27) or SDDC (26). Note that inte-
grating the flow (24) requires solving an Ordinary Differential
Equation (ODE), which we address using off-the-shelf solvers
(more information is provided in the Appendix in Table V).
After computing the flow, applying Equation (26) or (27)
reshapes the vector fields to avoid obstacles while preserving
global contraction guarantees. Algorithm 2 summarizes how a
robot is controlled using our approach.
V. OBSTACLE AVOIDANCE METRICS
We here introduce two novel metrics: Relative Flow Curva-
ture (RFC) and Vector Field Misalignment (VM), to quan-
titatively assess the obstacle avoidance performance of our
approach and state-of-the-art methods. In contrast to stan-
dard metrics such as the Dynamic Time Warping Distance
Demonstrations
Time in s
Amplitude
(a) Without friction
Demonstrations
Time in s
Amplitude
(b) With swept features (Eq. (21))
Demonstrations
Time in s
Amplitude
(c) With friction and f defined by Eq. (29)
Figure 6: Comparison of contraction-preserving obstacle avoidance using SDDC and SDC on an example of the LASA dataset. The vector
field modulated by the SDDC is represented by a gray flow stream while the box-shaped obstacle is depicted by the red solid line. The
bottom plots show the magnitude of the velocity profile along the trajectory.
(DTWD), that measure reconstruction errors, the proposed
metrics focus instead on changes of the learned vector field
introduced by the obstacle avoidance modulation.
A. Relative Flow Curvature
To ensure that the obstacle avoidance maneuvers do not
introduce jerky or sharp trajectories, we analyze the curvature
of the modulated vector field. This metric, termed RFC,
should ideally remain similar to the original vector fields
around obstacles. Specifically, RFC compares the maximal
curvature  along the modulated trajectory m against the
maximal curvature of the base trajectory base. The curvature
measures how sharply a trajectory  bends at a given point
relative to the tangential direction , and it is defined as,
with  denoting the cross product, (t) and (t) being
the velocity and acceleration along the trajectory. Given the
curvature (30), the RFC metric is defined as follows,
xbase(x)max
B. Vector Field Misalignment
When considering contractive stable vector fields, it is par-
ticularly important to preserve the learned vector field patterns
as much as possible in order to maintain the essence of the
skill. Therefore, we propose to compute the cosine similarity
between the learned vector field fc and the modulated vector
field fm along the rolled-out obstacle-avoiding trajectory.
Since we aim to quantify the degree of misalignment between
the two vector fields, we define this metric as,
fc(x)  fm(x)
fc(x) fm(x)
A high VM value indicates that the base vector field and the
modulated vector field significantly deviate from each other.
Therefore a low VM is desirable as this may indicate that the
learned vector field patterns are just slightly modified.
VI. EXPERIMENTS
In the following experiments, we systematically analyze
the performance, real-time feasibility, and potential edge-cases
of the proposed obstacle avoidance methods. Thereby, we
evaluate the proposed methods SDDC and SDC on the 2D
LASA dataset  and on two real-world tasks: EMPTYING
A DISHWASHER and OPENING A DISHWASHER. These experi-
ments are carried out in a kitchen environment with unknown
obstacles. For the real-world experiments, the robot surface
is learned as an SDF function while the scene is represented
by an incrementally-sampled point cloud. For the 2D LASA
dataset experiments, only implicit models of the obstacles are
learned while the robot is assumed to be a virtual point. Here,
simple geometries such as circles, rectangles, triangles or arcs
are used as obstacles, as shown in Fig. 7.
Our methods are compared against MM  as this is
the only contraction-preserving obstacle avoidance method
known to us, which was also employed in combination with
NCDS . Moreover, we compare our methods against the
relies on a natural gradient formulation and thus does not
Obstacle surface
Figure 7: Illustration
of the obstacles SDF
used in the 2D LASA
dataset experiments.
represent
distance
the obstacle surface,
depicted as a solid
simple obstacles are
preserve contraction. Additionally, we consider classical Ar-
tificial Repulsive Potential Field (ARPF) . We ablate our
methods using different SDF functions based on MLP, BP,
and simple geometric primitives. These different versions are
compared against Hilbert maps  as this method was used
in combination with DT for obstacle avoidance .
A. Evaluation Metrics
The following metrics are used to quantitatively evaluate
the obstacle avoidance performance. Firstly, we evaluate our
methods ability to preserve the underlying learned skill dur-
ing obstacle avoidance. To do so, we compare the skills
execution with and without obstacles using the DTWD .
A low DTWD indicates that the reproduced trajectory was
slightly modified by the obstacle avoidance term. Secondly,
we compute the minimum distance Dmin  minxm SDF(x)
between the robot surface and the obstacle over the course of
the skill execution. Our goal should be to keep this distance
sufficiently large to guarantee a collision-free skill execution.
or discontinuous trajectories, we use our proposed RFC met-
ric (31) to measure the curvature of the modulated vector
field. As fourth metric we analyze the trajectory jerkiness,
which measures abrupt acceleration changes possibly intro-
duced by the obstacle avoidance term. To assess this, we
compare the maximal trajectory jerkiness in both obstacle-free
... base(x) and obstacle-avoidance settings ... m(x), resulting in
the Modulation Jerk (MJ) metric. The jerk difference should
be as small as possible. Finally, we evaluate the proposed VM
metric (32), which measures the deviation between the base
vector field and the modulated vector field. Details about the
B. Implementation Details
All experiments are run on a NVIDIA RTX A2000 12GB
GPU and a 12th Gen Intel(R) Core(TM) i5-12600K CPU.
used for learning the skill models and the obstacle implicit
representations.
1) Neural Contractive Dynamical System: Our NCDS im-
plementation fundamentally follows that of Beik-Mohammadi
et al. . The NCDS Jacobian network is modeled using an
MLP with 2 hidden layers, each consisting of 100 units and
employing TANH activation functions. We define the total loss
function as a combination of Equations (12), (13) and (14),
with weighting factors   1.0  103 and noise  1.0
All models are trained for 1000 epochs with a learning rate
of 1  103 using the Adam optimizer. A decay factor of
0.1 is applied every 250 epochs to improve training stability.
interpolated such that each trajectory consists of exactly 1000
points. At inference time, a fourth-order Runge-Kutta solver
with the 38 rule is employed to solve the ODE in Equa-
tion (10) using two solver steps.
2) Signed Distance Fields: For the LASA dataset exper-
description of the simple geometric shapes, as displayed in
Fig. 7. Using this representation, we sample N  160K
points {xi}N
i0 from a grid around the obstacle surface and we
then assign each point its corresponding SDF di  SDF(xi)
and gradient values gi  xSDF(xi). Given this training set
D  {(xi, di, gi)}N
an MLP with an hourglass-shaped architecture of size (128, 64,
The loss function is a combination of a reconstruction loss
tension loss , leading to,
L()  wSDFLSDF  wgradLgrad  weikLeik  wtenLten,
where wSDF, wgrad, weik and wtension are weighting factors with
values wSDF  10.0, weik  0.01, wgrad  0.1 and wten
0.01. The models are trained for 5000 epochs using an Adam
optimizer with a learning rate of 1  103. In addition, we
learn a BP-based SDF similarly to Li et al. . We choose
a model size of 8 basis functions, which are trained for 200
epochs using the training set D.
implicit
representation of the 7-DoF Franka-Emika Panda robot.
On the one hand, we use the BP architecture proposed by Li
et al. . We choose 14 basis functions and train the model
for 200 epochs. On the other hand, we learn a CDF of
the robot based on a MLP model combined with positional
encoding and adopt the architecture of Li et al. . We
choose the same loss as described for the 2D MLP model but
with an architecture of size (1024, 512, 256, 128, 128) and
learn the model for 50000 epochs.
C. Baselines
To compare our approach with state-of-the-art methods, we
must adapt them to work with SDFs. Firstly, Huber et al.
used MM with a custom distance function M designed for
simple geometric primitives, which is not directly comparable
to our framework. Thus, we define a distance function such
that Hs  {x Rd  MSDF(x)  1}, resulting in,
MSDF(x)  (SDF(x)  1)2p .
Given this distance function MSDF, we compute the mod-
ulation matrix M according to Huber et al. . So, the
modulated vector field is,
x  M(x)fc(x).
the diffeomorphism based on Hilbert maps  by our dif-
feomorphism  from Eq. (24). This results in the modified
natural gradient system,
y  fDT(x, y)  G(y)1fc((x, y))
with the Riemannian Metric G  J
J. Finally, we adapt
the ARPF method  by defining the repulsive potential
VARPF via the SDF function, as follows,
VARPF(x)  1
SDF(x) tsafe
with safety threshold tsafe  0.1 and a positive constant
104. Given this repulsive potential, the resulting dynamics of
the adapted contractive system fc is,
x  fc xVARPF(x).
D. Validation on the LASA Dataset
The aim of these experiments is to determine the quality
and efficiency of obstacle avoidance as well as the limitation
of the proposed methods on the basis of simplified scenarios.
1) Experimental Setup: The LASA dataset  is used to
validate the proposed pipeline using a 2D dataset, consisting
of 30 2D handwritten movements. Each movement consists of
seven demonstrations. As an example, we use the Sine move-
ment from the LASA dataset for the following experiments
(see Fig. 3). In this case, we assume a virtual point-shaped
robot following the learned contractive NCDS models trained
on the Sine dataset. The task for the robot is to avoid one of
the obstacles shown in Fig. 7. In addition, in the Appendix
(see Fig. 14) multi-modal robot skills are also investigated.
The obstacle is represented by an implicit distance function.
(see Fig. 7). These are also used to generate the training data,
which serve as the ground truth. Additionally, we learn an
SDF represented by a MLP and another represented via BP.
We analyze the performance of the methods for 40 different
trajectories per obstacle, each with different obstacle positions.
2) Obstacle Avoidance Results: As an exemplary scene,
we place the box-shaped obstacle in the trajectory path and
apply our proposed method and compute both the trajectory
with and without obstacle avoidance. As shown in Fig. 6c the
learned contractive vector field is deflected around the obstacle
and thus we can successfully avoid an convex obstacle using
our proposed method. If the barrier function is additionally
extended with the swept feature, Fig. 6b shows that the vector
field away from the obstacle is less influenced and thus the
movement in this area follows more closely the dynamics
learned by NCDS.
shapes. In the following, we investigate how the methods
behave with concave surfaces. As shown in Fig. 8, when
using the SDT framework, the flow gets stuck in the concave
region. Note that the learned SDF does not provide any global
information regarding the shape of the obstacle. The curvature
can therefore only be calculated locally. Consequently, the
vector field is deflected at the edges of the obstacle profile,
regardless of the obstacle shape. Therefore, Huber et al.
suggest defining a reference point xr that specifies a clear
direction for the flow. However, this does not serve any
purpose for a SDF function, as the global information is only
implicitly represented. In addition, the reference point would
Demonstrations
Time in s
Amplitude
Figure 8:
Obstacle
avoidance
barrier on a NCDS
model trained on the
dataset.
arc-shaped
obstacle
depicted
red line. The velocity
absolute
velocity
trajectory. The vector
modulated
represented by gray
have to be adjusted continuously for dynamic objects. This
confirms our expectations that avoidance of concave obstacles
may prevent a complete execution of the trajectory, thus we
consider our method primarily relevant for convex obstacles.
3) Barrier Functions Hyperparameter: We here analyze
the influence of the hyperparameter sgrad in Eq. (19) on the
obstacle avoidance behavior, using the metrics proposed in
Section VI-A. Table I reports the metrics for three different
values of sgrad. The experiments show that higher values of
sgrad increase the minimum distance to the obstacle. This in
turn has a negative influence on the DTWD and the VM
obstacle avoidance and thus modulates a larger region of
the learned vector field. In addition, the results show that
the curvature decreases for larger values of sgrad, except for
smoothly. We therefore see a potential trade-off between a
smooth modulation with higher distance to the obstacle (i.e.,
high sgrad values), and a more accurate alignment to the
skill vector field, but with less smooth modulation (i.e., low
sgrad values). Moreover, the swept features have a significant
positive impact on the majority of the metrics, particularly
noticeable in the RFC and VM metric. This can be explained
by the fact that these swept features minimize the area of
influence of the obstacle avoidance term.
4) Comparison to State-Of-The-Art: To compare our pro-
posed SDC and SDDC methods with state-of-the-art ap-
parison. We then evaluate all approaches using three distinct
SDFs architectures. The results are summarized in Table II.
metrics such as RFC, VM and DTWD. It is noteworthy that
ARPF exhibits particularly strong performance with respect
to the MJ metric, indicating jerk-free obstacle avoidance.
Appendix B3.
Another noticeable finding is that SDDC produces relatively
large VM values, indicating weaker alignment with the original
Table I: Quantitative analysis of the influence of sgrad on the obstacle
avoidance behavior according to Eq. 19. Only obstacles based on
geometric primitives (GP) are considered. Each metric is computed
as the average over 40 trajectories.
sgrad  0.05
sgrad  0.10
sgrad  0.20
contractive vector field during obstacle avoidance. In addition,
its low Dmin and high DTWD values imply that SDDC
follows a suboptimal path. This observation is qualitatively
reinforced by Fig. 9, where SDDC takes a longer path around
the obstacle. Nevertheless, this path is characterized by a
particularly smooth trajectory, as indicated by its low RFC
The differences among the three SDF functions are notice-
the metrics. However, the MLP-based SDF tends to exhibit
higher MJ and RFC values, indicating increased irregularities.
By contrast, the BP-based SDF appears more smooth, which
aligns with the features provided by polynomial-based func-
tions. In conclusion, the foregoing results demonstrate that

