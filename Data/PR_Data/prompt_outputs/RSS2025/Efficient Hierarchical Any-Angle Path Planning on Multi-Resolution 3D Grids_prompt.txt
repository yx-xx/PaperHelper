=== PDF文件: Efficient Hierarchical Any-Angle Path Planning on Multi-Resolution 3D Grids.pdf ===
=== 时间: 2025-07-22 15:49:23.080204 ===

请你只输出如下JSON，所有字段都必须有，且每个“关键词”字段只允许输出一个最核心的最有代表性的中文关键词，要中文关键词（不能是英文，不能是多个，不能有逗号、分号、空格），否则视为不合格。不要输出任何解释或正文，只输出JSON。
{
  "论文标题": "",
  "研究主题关键词": "",
  "应用场景关键词": "",
  "主要方法关键词": "",
  "创新点关键词": "",
  "主要结论关键词": ""
}
内容：Efficient Hierarchical Any-Angle Path Planning
on Multi-Resolution 3D Grids
Victor Reijgwart, Cesar Cadena, Roland Siegwart and Lionel Ott
Autonomous Systems Lab, ETH Zurich, Switzerland
approaches are widely used to represent large and complex
environments as they can efficiently capture their occupancy
and connectivity information. Yet widely used path planning
methods such as sampling and trajectory optimization do not
exploit this explicit connectivity information, and search-based
methods such as A suffer from scalability issues in large-scale
high-resolution maps. In many applications, Euclidean shortest
paths form the underpinning of the navigation system. For such
paths by connecting corners of obstacles with straight-line seg-
we present a method that has the optimality and completeness
properties of any-angle planners while overcoming computational
tractability issues common to search-based methods by exploiting
multi-resolution representations. Extensive experiments on real
and synthetic environments demonstrate the proposed approachs
solution quality and speed, outperforming even sampling-based
methods. The framework is open-sourced to allow the robotics
and planning community to build on our research.
I. INTRODUCTION
A core competency of robots is the ability to autonomously
navigate between areas of interest, such as storage spaces,
work sites, and inspection points, even if these locations
are far apart. Methods for solving this planning problem
can be categorized into optimization-, sampling- and search-
based approaches. Optimization-based methods produce high-
guess to converge to a good solution. This initial guess is often
obtained from a sampling- or search-based planner. Search-
based methods generally operate on a graph with a fixed
constructed from motion primitives. Meanwhile, sampling-
based methods build the graph by randomly sampling and
connecting collision-free robot configurations. Sampling-based
approaches are popular in practice due to their ability to find
solutions while only sparsely covering large, potentially high-
dimensional configuration spaces. However, extracting graphs
through random sampling discards much of the information
embedded in the volumetric map and neglects its underlying
structure. The information contained in discretized maps is
complete and cannot detect infeasibility in finite time. This
is particularly problematic in environments with narrow pas-
and feasibility is not guaranteed. This raises a hard-to-answer
question in sampling-based methods: How long should one try
Illustration of a solution generated by our proposed any-angle path
that efficiently traverse free space using a small number of waypoints which
tightly fit the obstacles (voxels shaded by height). A 2D slice of the multi-
resolution 3D cost field demonstrates how the hierarchical algorithm refines
resolution only where necessary, ensuring both efficiency and accuracy.
to find a solution before giving up?
For many applications, a volumetric maps adjacency graph
provides a reasonable discretization of the true, continuous
search space. Combining this graph with standard search al-
gorithms  allows resolution-complete solutions to be found
in finite time. While searching for the shortest path, A
and similar methods compute the optimal cost-to-come and
predecessor for each explored grid vertex. Their time and
space complexity, therefore, scales linearly with the explored
volume and cubically with the grid resolution . This is
particularly problematic in environments with dead-ends that
are deep relative to the grid resolution.
Octree-based
compactly
traversability information using multi-resolution. Evaluating
A directly on the adjacency graph of an octrees leaves
preserves the completeness of running it on a grid at the
highest resolution while offering significant memory and
runtime improvements . However, considering only the
octree leaves centers yields suboptimal paths in length and
smoothness . As illustrated in Figure 2, post-processing
steps such as path-shortening cannot resolve this issue since
the paths might not even be close to the true shortest path.
Any-angle planning algorithms, such as Theta , improve
path quality by allowing paths to deviate from grid edges,
connecting vertices in line of sight with straight lines. This
approach can yield paths up to 13 shorter than those
produced by A . In this paper, we extend Thetas cost
Comparison of A on an octrees leaves (left, blue), A on a fixed-
resolution grid (right, blue), and Theta (right, green). On the octree, A
produces highly suboptimal paths. While its search space includes a path
(dashed blue) on the correct side of the obstacle (striped box), this path is
ignored due to the detour introduced by passing through the leaves centers.
A on the grid finds shorter, smoother paths, but still performs worse than
Theta. Our method matches Thetas path quality while operating on octrees.
field formulation to efficiently represent large parts of the
search space at coarser resolutions. Additionally, we propose
a coarse-to-fine search algorithm that starts at the coarsest res-
olution and refines solutions only in regions requiring higher
cost without sacrificing accuracy.
In summary, the main contribution of this paper is a
search-based planner that combines the accuracy of any-angle
planning with the efficiency of multi-resolution representations
and hierarchical algorithms. Extensive evaluations on synthetic
and real-world maps demonstrate that the proposed method
retains Thetas accuracy while running up to two orders of
magnitude faster. Compared to well-established search- and
sampling-based planners, it consistently finds near-optimal
paths and, in cluttered environments, runs even faster than
sampling-based planners. The complete framework is open-
sourced1 to allow the planning and robotics communities to
build on these results.
II. RELATED WORK
planning
generally
categorized
into optimization-, sampling-, and search-based approaches.
Sampling-based methods are most commonly used for global
randomized methods such as RRT  and RRTConnect
provide no guarantees on the quality of their solutions. Variants
such as RRT  are guaranteed to converge the optimal so-
lution as the number of samples approaches infinity. However,
they do not provide bounds on their intermediate solutions
and stopping them after a finite time leads to different paths
even when the start and goal positions are the same . A
challenge in practice is that the inconsistency of randomized
planners worsens in cluttered environments, and finding solu-
tions through narrow passages can take a very long time.
Search-based planners such as A  operate on a dis-
cretized search space and are deterministic, complete, and
terminate in finite time, explicitly reporting when no solution
exists. However, using a fixed-resolution 3D occupancy maps
adjacency graph as the space discretization results in runtimes
that grow linearly with volume and cubically with resolution,
making it impractical for large or high-resolution maps.
Several research efforts have explored hierarchical ap-
proaches to improve the scalability of search-based plan-
ning. Kambhampati and Davis  applied A to the oc-
trees leaves, compactly representing traversable space and
achieving significant efficiency improvements, albeit at the
cost of longer, jagged paths. Funk et al.  extended this
approach to orientation-aware planning in large environments
with narrow openings. CFA  proposed a coarse-to-fine
by refinement at the grid cell level. HPA  generalized
this concept to multi-level hierarchies of pre-processed clus-
ters. Beyond these methods, iterative  and information-
theoretic  approaches have also been proposed. Re-
weighted-A searches at different resolution levels can share
information to combine their strengths. However, a significant
drawback of all these methods is that their path lengths are, at
Any-angle planners improve upon A by allowing devia-
tions from the grids edges, finding up to 13 shorter
paths  by better approximating true shortest paths in
continuous space, which are taut  straight except at inflec-
tion points wrapping around obstacles. Theta , a widely
adopted any-angle planner, achieves high accuracy in diverse
environments  by connecting each vertex to its best visible
predecessor. While these deviations improve accuracy, Theta
propagates information only along grid edges, enabling simple
and efficient implementation. However, in 3D, it incurs signif-
icant runtime overhead due to the numerous visibility checks
required to ensure vertex-predecessor edges are collision-free.
LazyTheta  addresses this limitation with lazy visibility
with minimal impact on path quality.
Multi-resolution methods for any-angle planning have also
been explored. Chen et al.  introduced framed quadtrees,
which pad leaf nodes with high-resolution vertices to permit
a broader range of angles through each leaf. While effective
in 2D, this approach scales poorly for 3D Euclidean shortest
ditional term that grows quartically with padding resolution.
Closest to our work, Faria et al.  applied LazyTheta
to octree leaves. However, their method produces arbitrarily
suboptimal paths as it considers only leaf centers. In contrast,
we explicitly consider the high-resolution vertices within each
leaf and dynamically refine the octree to bound the approx-
imation error. Additionally, a custom initialization procedure
ensures all potentially optimal inflection points are evaluated.
Extensive comparisons and ablations demonstrate that these
improvements yield significantly shorter, smoother paths.
III. PROBLEM STATEMENT
This paper presents a method for finding collision-free
Euclidean shortest paths between a start and goal point in
2D or 3D workspaces, given an occupancy map representing
obstacles. To simplify collision checking, we approximate the
robot as a bounding sphere and inflate all obstacles by its
algorithm does not account for motion constraints.
IV. METHOD
In this section, we describe the components of our planner.
of intermediate solutions in any-angle planning. Building on
consists of: i) an approach that ensures all plausible waypoints
are efficiently considered, and ii) a coarse-to-fine method to
explore the search space spanned by the previously generated
waypoints. Formal statements on our methods completeness,
optimality and time-complexity are provided in Appendix C.
A. Any-angle planning
Any-angle planners produce shorter and smoother paths
than A by allowing paths to deviate from grid edges (Figure 2
right), better approximating true shortest paths in continuous
space. A necessary condition for Euclidean shortest paths is
that they are taut, i.e. consisting of straight line segments
connected at inflection points where the path wraps tightly
around obstacles.
We base our planner on Theta , which closely follows
As algorithm. Both planners check whether a path through
an expanded node can improve the cost-to-come (g cost) of
its neighbors. However, Theta introduces a key improvement:
for each neighbor, it performs a visibility check to determine if
it can be directly connected to the nodes predecessor. As
illustrated in Figure 3, this eliminates intermediate waypoints,
further reducing g costs and avoiding detours.
B. Multi-resolution cost field representation
Search-based planners such as A and Theta compute the
minimum g cost and best predecessor for each (grid)
vertex expanded during the search. Since these two properties
are often stored together, we refer to their combination as the
cost field.
By construction, neighboring grid vertices rarely share the
same g cost. In Theta, however, large regions are often
dominated by the same predecessor (Fig. 3). The g cost
of any vertex s is defined as the g cost of its predecessor plus
the distance between them. Consequently, the cost field can
be compressed losslessly by storing predecessor(V) and
g(predecessor(V)) for each region V. The g cost of any
vertex s within a region V can then be retrieved using
g(s)  g(sp)  c(sp, s)
s V, sp  predecessor(V)
where c(sp, s) is the Euclidean distance from sp to s.
To exploit this, we propose to partition the cost field into
multi-resolution cubes corresponding to an octrees leaves.
Illustration of the cost-to-come (g cost) and predecessor fields of
Theta in a 2D environment with a single obstacle (striped box). The g cost
field (left) changes from cell to cell, while the predecessor field (right) is
largely constant. All cells to the left of the obstacle (green) are directly visible
from the start vertex (black circle) and thus use it as their predecessor. Cells
near the top right (purple) connect through the cell at the obstacles top-left
Illustration of the importance of initializing inflection points. Without
initialization (left), the retrieved shortest path may take large detours around
obstacles. Initializing the cost field at a higher resolution near obstacles (right)
resolves this issue, resulting in shorter, smoother paths. As the number of
added subvolumes (blue) is small, the performance overhead remains minimal.
This regular structure enables efficient storage, fast random
ment between the search space and octree-based traversability
C. Cost field initialization
Just as typical search-based planners where a vertexs
predecessor is itself a vertex, we define the predecessors of
subvolumes as subvolumes. While a single subvolume could
encompass the start, goal, and several inflection points, we
initialize the cost field such that each subvolume contains
at most one such waypoint to reduce bookkeeping and the
runtime complexity of neighborhood operations.
Initializing subvolumes at the minimum resolution required
to avoid occupied leaves in the maps octree suffices to
guarantee resolution completeness . However, as shown
in Figure 4 (left), this approach often results in paths taking
significant detours around obstacles. From the definition of
taut paths, optimal inflection points can only appear next to
obstacles. Thus, considering all vertices of a high-resolution
grid that are traversable and adjacent to an obstacle ensures
that no inflection points that would be considered by Theta on
the same grid are missed. This initialization can be performed
Algorithm 1: Heuristic-guided search over subvolumes
2 closed
3 g(sstart) 0
4 predecessor(Vstart) sstart
5 open.insert(Vstart, ComputeFScore(Vstart))
6 while open  do
V open.pop()
if sgoal V then
return PathFound
closed closed {V}
g(Vcenter) g(predecessor(V))
c(predecessor(V), Vcenter)
UpdateSubvolume(V, Vroot)
15 return NoPathFound
globally or incrementally as the search progresses through
the traversability map. In our tests, we adopt the incremental
explored volume rather than the maps total size.
D. Multi-resolution search
Search-based planning in 3D spaces is computationally
challenging as the number of vertices grows rapidly with
increasing resolution. To address this, our approach explores
the search space at the coarsest possible resolution and dynam-
ically refines it only where needed to maintain accuracy. After
initializing the cost field as described in Section IV-C, our any-
angle planner computes each subvolumes predecessor(V)
and g(predecessor(V)) by running a modified version of
A over the octrees leaves. Similar to A, the algorithm uses
a min-priority queue (open) to expand elements sorted by
their estimated goal-reaching cost (f score). However, unlike
contain many vertices, which are processed together.
Algorithm 1 shows our planners main loop. For each
expanded subvolume V, the algorithm first checks whether
it contains the goal vertex sgoal (Li. 8). If so, the search
terminates. Otherwise, V is added to the closed set, and the g
cost for its center is computed (Li. 12) and stored for potential
use as a predecessor. Finally, the UpdateSubvolume
function processes all adjacent subvolumes, which may in-
clude 26 or more multi-resolution neighbors.
E. Dynamic refinement
Throughout the majority of the environment, the cost field
resolution chosen by the initialization procedure suffices. How-
the subvolume. For instance, in Figure 5, vertices toward the
top right are optimally reached by passing above the obstacle,
whereas passing below the obstacle provides shorter paths to
the vertices on the bottom right. In such cases, instead of
Illustration of our dynamic refinement procedure. When a new path
(dashed arrow) is discovered to a subvolume V (left) that has already been
reached (solid arrow), we evaluate its effect on the cost to reach each vertex
in V. The algorithm handles three cases: i) the new path reduces the cost for
all vertices, replacing the previous path; ii) the new path does not improve any
costs and is ignored; iii) some costs improve while others worsen. In this last
case (right), V is recursively subdivided until each child subvolume is fully
resolved under case i or ii. Subvolumes are colored by their predecessor.
Algorithm 2: Recursive octree node updates
1 Function UpdateSubvolume(V, V) is
if IsLeaf(V) then
Status UpdateCost(V, V)
if Status  StrictlyBetter then
if V open then
open.remove(V)
open.insert(V, ComputeFScore(V))
else if Status  NotBetter then
else  Status  Ambiguous
open.remove(V)
foreach V
child V do
child closed then
sp predecessor(V)
child open then
predecessor(V
child) sp
open.insert(V
if AreAdjacent(V, V
child  V then
UpdateSubvolume(V, V
29 Function AreAdjacent(Va, Vb) is
sep cmax(Va
min) cmin(Va
return sep.x 1 and sep.y 1 and sep.z 1
assigning a single suboptimal predecessor to the entire
Leveraging the hierarchical structure of octrees, this refine-
ment can efficiently be integrated into our multi-resolution
planner through a recursive UpdateSubvolume method
(Alg. 2). Starting at the octrees root V
method handles two cases. If V is a leaf, the function
calls UpdateCost to evaluate whether a path through the
expanded subvolume V or its predecessor(V) improves
the g cost of V. Since V can contain multiple vertices,
the comparison has three possible outcomes: i) using V or
predecessor(V) reduces the cost for all vertices in V,
updating its predecessor and reprioritizing it in the open
queue; ii) no costs improve and both predecessors are ignored;
or iii) some costs improve while others worsen, flagging V
for refinement.
In the second case, for non-leaf subvolumes or those flagged
for refinement, the function iterates over Vs children, skip-
ping closed nodes. Newly created children inherit their
parents predecessor and are added to the open queue,
ensuring the full region V covered is eventually processed.
The function then recursively visits each child adjacent to
2. AreAdjacent tests whether subvolumes Va and Vb
touch or overlap, which holds if the minimum offset between
their Axis-Aligned Bounding Boxes (AABBs) is at most 1
along every axis on the highest-resolution grid. This offset
is computed from the coefficient-wise max (cmax) and min
(cmin) of their AABB corners V
min and V
The UpdateCost function (Alg. 3) implements the com-
parison between Vs current predecessor, sp, and two
candidate predecessors: an inflection point at the center of
g cost for all vertices s V compared to sp and sc, the
function returns NotBetter, indicating no changes are required.
s V, the predecessor is updated and StrictlyBetter is
returned. If neither condition is fully satisfied, the function
returns Ambiguous, signaling the need for further refinement.
In practice, tolerating small path length suboptimalities may
be acceptable, particularly if it leads to efficiency improve-
ments. To quantify this, we define the worst-case suboptimality
of sp relative to an alternative predecessor si over V as
g(sp)  c(sp, s) g(si) c(si, s)
c(sp, s)
where c(sa, sb) is the straight-line distance from sa to sb.
Since the error is normalized by edge length, the total accu-
mulated error along the path grows at most proportionally with
the paths length.
To bound this error, we introduce , which represents the
worst-case relative path length suboptimality. The function
IsBetterOrSimilar (Li. 22) applies this threshold to
decide whether a new predecessor should be accepted. For
predecessor than sb for every vertex in V. The planner then
refines each subvolume until its children are strictly dominated
by a single predecessor. In general, UpdateSubvolume
recurses until the following condition holds for si {sp, sc}:
predecessor
Algorithm 3: Computing cost updates and heuristics
1 Function UpdateCost(V, V) is
sc Vcenter
sp predecessor(V)
sp predecessor(V)
if LineOfSight(sp, V) then
Ray traced connection
if IsBetterOrSimilar(sp, sp, V) then
return NotBetter
else if IsBetterOrSimilar(sp, sp, V)
predecessor(V) sp
return StrictlyBetter
Direct neighbor connection
if IsBetterOrSimilar(sp, sc, V) then
return NotBetter
else if IsBetterOrSimilar(sc, sp, V)
predecessor(V) sc
return StrictlyBetter
return Ambiguous
22 Function IsBetterOrSimilar(sa, sb, V) is
if s V : g(sa)  c(sa, s) <
g(sb)  c(sb, s)   c(sa, s) then
return True
return False
29 Function ComputeFScore(V) is
sp predecessor(V)
return minsV [g(sp)  c(sp, s)  h(s)]
resolution planner computes consistent f scores for sorting
the open queue, by identifying the minimum f score across
all vertices in V. Although IsBetterOrSimilar and
ComputeFScore consider subvolumes with many vertices,
the computational burden is significantly reduced in practice
because c(sp, s) and h(s) are straight-line distances, requiring
only a few critical vertices to be checked.
V. EXPERIMENTS
In the experiments, we start with an evaluation of our multi-
resolution planners initialization and dynamic refinement pro-
cedures. Then, we compare our method to other path-planning
approaches based on success rate, path length, and runtime.
Path length [relative]
Eect of initializing inection points at dierent resolutions
Inection point initialization resolution
Speedup [relative]
Path length [m]
Path length [m]
Fig. 6. Initialization procedures impact on path length and runtime relative to
Theta (blue line). Reading the plot from left to right, we see how increasing
the inflection point initialization resolution brings our path lengths (top) closer
to Theta while remaining significantly faster (bottom).
The result plots share an overall structure, showing the mea-
sured quantity on the Y-axis, while the property being varied is
along the X-axis. The result distributions are presented as box
plots with individual results shown as dots, colored according
to the true path length. Where results are relative to a baseline,
a blue line indicates baseline performance.
A. Impact of initialization and refinement
The evaluation of our initialization and refinement proce-
dures impact on performance are conducted on five synthetic
resolution. They are generated by adding 0, 1000, 2000, 3000,
and 4000 randomly shaped obstacles to an initially empty
100 random collision-free start-goal pairs (500 total) were
sampled.
1) Inflection point initialization: To evaluate the signifi-
cance of the initialization procedure (Section IV-C), we com-
pare the path lengths and execution times of our planner with
and without initialization to Theta running at the highest
resolution. As our method allows defining the initialization
ranging from 1.6 m to 10 cm. For this analysis, the dynamic
refinement strategy (Section IV-E) is disabled to isolate the
effect of initialization.
The results in Figure 6 (top) show that increasing the
inflection point initialization resolution moves the path lengths
of our planner closer to those of Theta. On average, path
lengths converge to values close to Theta, especially for
longer paths (deep purple). Outliers primarily correspond to
short paths (light orange), where small differences are ampli-
fied when normalized by the short path length and runtime
values of Theta.
At coarser resolutions (80 cm), initializing inflection
points yields no notable improvement over No init be-
cause the cost fields octree conforms to the obstacles in the
Path length [relative]
Eect of dynamic renement driven by approximation threshold
Match map
Approximation error threshold
Speedup [relative]
Path length [m]
Path length [m]
Ablation showing how the dynamic refinement strategy affects the
path length and speedup (log scale) of our method relative to Theta (blue
line). Reading the plot from left to right, we see that as the threshold is
occupancy map. This results in most occupied cells being
surrounded by medium to high-resolution subvolumes, render-
ing low-resolution initializations redundant. Additionally, the
occupancy map and cost field are stored using an optimized
octree data structure , limiting the coarsest resolution to
6.4 m, implicitly preventing extremely bad solutions. At higher
paths than Theta, as Theta is not guaranteed to be
optimal.
Looking at runtime results (Figure 6 bottom) we see that
increasing the initialization resolution generally increases run-
subvolumes and consider more inflection points as predeces-
sors. Note that the clusters of points at the top of the bottom
plot correspond to queries in the 0-obstacle environment.
Since these involve no obstacles requiring initialization, their
speedup is independent of the initialization resolution.
2) Refinement strategy: To evaluate the effect of the dy-
namic refinement procedure (Section IV-E), we run our plan-
ner with different approximation error thresholds  (Eq. (3))
and compare the results to Theta. The initialization pro-
cedure (Section IV-C) is disabled to isolate the effect of
refinement. We test  values ranging from 101 to 103,
along with two special cases: lossless refinement (  0) and
no refinement, which we refer to as Match map. Because
the planner can only traverse fully unoccupied cells, the
resolution of the cost field must always match or exceed the
occupancy maps leaf resolution. When refinement and initial-
ization are disabled, the cost fields subvolumes exactly match
the occupancy maps leaves, resulting in the Match map
configuration.
The results in Figure 7 show that as the threshold
is tightened, the path lengths gradually approach those of
Theta. Similar to the initialization ablations, the error
relative to Theta is already low for Match map because
SUMMARY OF ABLATIONS. PATH LENGTHS RELATIVE TO THETA.
Initialization
Path length
Refinement
very coarse free space leaves rarely occur in occupancy
maps. This highlights that our multi-resolution, any-angle
cost field formulation is inherently accurate, even at the
moderate resolutions that dominate most free space. As  is
suboptimality thresholds. However, some outliers persist,
and the paths do not fully converge to Theta, even for
which limits the discovery of critical inflection points. In terms
of runtime, reducing  gradually increases computation, as
smaller thresholds require more refinement steps.
In conclusion, as shown in Table I, initialization and refine-
ment each reduce the mean and variance of path lengths, with
their combination providing the greatest improvement.
B. Comparisons with other planners
The comparisons are performed on maps of four real envi-
ronments (Mine, Cloister, Math, and Park sequences of
the Newer College Dataset ) mapped with wavemap
at 10 cm resolution. These sequences represent constrained in-
door (Mine), mixed indoor-outdoor (Cloister), large urban
(Math), and large vegetated environments (Park). Obstacles
were inflated by 35 cm to account for the robots radius. For
each map, 100 random collision-free start-goal pairs (400 total)
were sampled. To assess how each planner handles unsolvable
We compare the success rates, path lengths, and execution
times of our proposed multi-resolution planner to a represen-
tative set of search and sampling-based planners. In terms of
search-based planners, we implemented fixed-resolution ver-
sions of A , Theta , and LazyTheta . For A,
we used the octile distance heuristic, which is consistent on 26-
connected grids, as we found it to run up to 70 faster than us-
ing the Euclidean distance heuristic. Additionally, we include
the reference implementation of OctreeLazyTheta
as a multi-resolution baseline. For sampling-based planning,
we used the RRTConnect  and RRT  implementa-
tions from the Open Motion Planning Library . While
RRTConnect terminates immediately once a path is found,
RRT does not. Therefore, we include three RRT variants
with increasing time budgets, namely RRT 0.1s, RRT 1s
and RRT 10s. Note that RRTConnect is also limited to a
maximum time budget of 10 s, to keep it from running forever
when a planning query is infeasible.
We evaluate three variants of our multi-resolution planner:
algorithm as described in the method section. To improve run-
time further, OursLazy and OursFast incorporate lazy visibility
visibility evaluations until necessary. These variants modify
TABLE II
PLANNING SUCCESS RATES PER MAP FOR 100 RANDOMLY SAMPLED
QUERIES EACH, INCLUDING INFEASIBLE CASES.
Success rate ()
Cloister
LazyTheta
OctreeLazyTheta
RRTConnect
RRT 0.1s
Ours Lazy
Ours Fast
the baseline algorithm as detailed in Appendix B, applying
the principles of LazyTheta . The specific settings we
use for our three planner variants are:
To ensure fair comparisons, all planners, including ours,
use optimized data structures and subroutines. The fixed-
resolution search-based planners store their cost fields using
a hashed voxel block data structure , while our multi-
resolution planner employs a hashed octree data structure .
These planners and all RRT variants use wavemaps hi-
erarchical occupancy map and multi-resolution ray tracer
for fast traversability and visibility checking. As motivated
in Section III, we inflate all obstacles by the robots ra-
tom visibility checker, to match this setup. All experiments are
run single-threaded on the same benchmarking server with an
Intel i9-9900K CPU and 64 GB of RAM.
1) Success rates: Starting with the success rates shown in
Table II, all search-based planners perform equally well. As
the start and goal pose pairs can contain infeasible planning
ments. For example, in Mine where none of the planners
succeed in more than 88 out of 100 queries due to limited
connectivity between areas.
sampling-based
RRTConnect
achieves the highest success rate, performing almost as well
as the search-based planners. Its bidirectional tree growth
and lack of rewiring provide an efficiency advantage over
RRT 10s, which comes in a close second (both planners
operate within a maximum time budget of 10 s). RRT 1s
trails slightly behind RRT 10s in simpler environments
but struggles in maps that are large (Park) or have narrow
passages (Cloister), as these scenarios require extensive
sampling to ensure adequate coverage or density. Finally,
RRT 0.1s performs reasonably well only in the Math
visibility.
We verified that for every query where at least one planner
empirical finding suggests that our multi-resolution planners
Path length [m]
Path length comparison
LTheta OTheta RRTCon RRT0.1 RRT1 RRT10
Path length [relative]
Path length [m]
Path length [m]
Path lengths for selected search- and sampling-based planners and
three variants of our multi-resolution planner. The upper plot shows absolute
Outliers for sampling-based planners are partially omitted in the lower plot.
In particular, only the bottom few quantiles of RRTConnect are visible.
TABLE III
AVERAGE PATH LENGTHS PER MAP FOR QUERIES WHERE ALL PLANNERS
SUCCEEDED.
Mean path length (m)
Cloister
LazyTheta
OctreeLazyTheta
RRTConnect
RRT 0.1s
Ours Lazy
Ours Fast
maintain the completeness guarantee of their fixed-resolution
counterparts. Additionally, there were no cases where a
sampling-based planner found a solution that the search-based
planners could not. This supports the idea that the adjacency
graph of an occupancy map provides a reliable approximation
of the solution space.
2) Path length: Moving on to the path quality evaluations,
we compare the average path lengths for all planners. To
ensure fairness, only queries where all planners succeeded are
on longer paths. As shown in Table III, Theta consistently
finds the shortest paths on all maps. LazyTheta follows
achieves similar results. OursLazy and OursFast also perform
exceeding Theta by more than 0.5. In contrast, the RRT
variants gradually increase in path length as their time budgets
decrease. A and OctreeLazyTheta also yield noticeably
longer paths, as A is constrained to a 26-connected grid and
OctreeLazyTheta restricts paths to octree leaf centers.
Execution time [s]
Execution time comparison
LTheta OTheta RRTCon RRT0.1 RRT1 RRT10
Speedup [relative]
Path length [m]
Path length [m]
Fig. 9. Execution times for selected search- and sampling-based planners and
three variants of our multi-resolution planner. The upper plot shows absolute
times (log scale), and the lower plot shows speedups relative to Theta (blue
The absolute and relative path length distributions in Fig-
ure 8 provide additional insights. The evaluated path lengths
ranged from 0 to 500m, with shorter paths being more
frequent due to the smaller connected areas in maps like
Mine and Cloister. Most planners find reasonable paths,
but RRTConnect stands out with significantly longer paths
and high variance. RRT 0.1s appears to find slightly shorter
paths on average, a bias explained by its failure to solve queries
with distant start and goal pairs.
For relative path lengths, Theta consistently finds the
shortest paths and is closely followed by LazyTheta.
While RRT occasionally surpasses Theta, it is less con-
sistent overall. For instance, RRT 10s features outliers with
paths up to 1.8 times longer than Theta. RRTConnect
exhibits extreme variance, with paths up to 16.8 times longer
than Theta. This highlights the importance of RRTs tree
rewiring for improving path quality. As predicted by Nash et
al. , A paths are far from optimal, with most paths being
at least 2 longer and some reaching the theoretical worst-
case of 13. Similarly, OctreeLazyTheta can introduce
significant detours, sometimes exceeding 25. Finally, Ours
closely matches Theta on average, demonstrating high
consistency and very few outliers. OursLazy introduces slight
variability due to lazy visibility checking, producing paths
that are marginally less direct. Also reducing the inflection
point initialization resolution in OursFast results in slightly
larger detours around obstacles. Nonetheless, paths produced
by OursFast remain suitable for many practical applications.
3) Runtime: The last metric we evaluate is execution time,
starting with the average runtime of each planner in each
averages to capture both successful and unsuccessful queries,
while the planning times of the RRT variants are not listed as
they are constant. Theta is the slowest planner by a large
margin. Enabling lazy visibility checking (LazyTheta)
improves its runtime by 6 to 9 times, but it remains signif-
TABLE IV
AVERAGE EXECUTION TIMES PER MAP FOR 100 RANDOMLY SAMPLED
QUERIES (RRT VARIANTS OMITTED DUE TO FIXED RUNTIMES).
Mean execution time (s)
Cloister
LazyTheta
OctreeLazyTheta
RRTConnect
Ours Lazy
Ours Fast
icantly slower than A. Interestingly, OctreeLazyTheta
is not faster than LazyTheta, indicating that octree-based
representations alone do not outperform optimized fixed-
resolution methods. However, substantial speedups can be
achieved through careful multi-resolution design. On average,
Ours is 8 times faster than Theta in confined environments
and 15 times faster in large open spaces. OursLazy achieves
similar gains, being 2 to 6 times faster than LazyTheta.
OursFast and RRTConnect are the fastest overall. OursFast
is up to 12 times faster than RRTConnect in confined
environments like Mine, while RRTC
