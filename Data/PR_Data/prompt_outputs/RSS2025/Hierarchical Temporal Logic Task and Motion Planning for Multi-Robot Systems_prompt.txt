=== PDF文件: Hierarchical Temporal Logic Task and Motion Planning for Multi-Robot Systems.pdf ===
=== 时间: 2025-07-22 15:50:07.907517 ===

请你只输出如下JSON，所有字段都必须有，且每个“关键词”字段只允许输出一个最核心的最有代表性的中文关键词，要中文关键词（不能是英文，不能是多个，不能有逗号、分号、空格），否则视为不合格。不要输出任何解释或正文，只输出JSON。
{
  "论文标题": "",
  "研究主题关键词": "",
  "应用场景关键词": "",
  "主要方法关键词": "",
  "创新点关键词": "",
  "主要结论关键词": ""
}
内容：Hierarchical Temporal Logic Task and Motion
Planning for Multi-Robot Systems
Zhongqi Wei,1, Xusheng Luo,1 and Changliu Liu1
Equal contributions
Robotics Institute, Carnegie Mellon University, Pittsburgh, PA 15213, USA
{zhongqi2, xushengl, cliu6}andrew.cmu.edu
AbstractTask and motion planning (TAMP) for multi-robot
motion planning, remains a challenging problem in robotics.
Existing TAMP approaches often struggle to scale effectively
for multi-robot systems with complex specifications, leading to
infeasible solutions and prolonged computation times. This work
addresses the TAMP problem in multi-robot settings where tasks
are specified using expressive hierarchical temporal logic and task
assignments are not pre-determined. Our approach leverages
the efficiency of hierarchical temporal logic specifications for
task-level planning and the optimization-based graph of convex
sets method for motion-level planning, integrating them within a
product graph framework. At the task level, we convert hierarchi-
cal temporal logic specifications into a single graph, embedding
task allocation within its edges. At the motion level, we represent
the feasible motions of multiple robots through convex sets in the
configuration space, guided by a sampling-based motion planner.
This formulation allows us to define the TAMP problem as a
shortest path search within the product graph, where efficient
convex optimization techniques can be applied. We prove that our
approach is both sound and complete under mild assumptions.
To enhance scalability, we introduce a pruning heuristic that
reduces the product graph size, enabling efficient planning for
high-dimensional multi-robot systems. Additionally, we extend
our framework to cooperative pick-and-place tasks involving
object handovers between robots. We evaluate our method
across various high-dimensional multi-robot scenarios, including
simulated and real-world environments with quadrupeds, robotic
our approach outperforms existing methods in execution time and
solution optimality while effectively scaling with task complexity.
I. INTRODUCTION
Multi-robot systems often need to collaborate effectively
and manage complex tasks. This has led to a growing demand
for planning systems that can enable robots to efficiently
execute long-horizon, intricate tasks. This challenge is com-
monly framed as a task and motion planning (TAMP) problem,
formulated as a combination of discrete task planning and
continuous motion planning . TAMP is known as an NP-
hard problem, particularly challenging for high-dimensional
multi-robot systems tasked with complex and long-horizon
operations. Traditionally, researchers in various fields have
addressed these problems separately. To simplify the issues,
certain assumptions are often employed, such as the exis-
tence of low-level controllers for task planning or the use
of pre-defined tasks in motion planning. However, in real-
world scenarios, predicting the feasibility of motion planning
given a specific task specification is difficult. A feasible task
Fig. 1: Given the hierarchical temporal logic specifica-
tions (14), which specify transferring the yellow, blue, and red
objects in order, our approach efficiently generates collision-
free trajectories for four robotic manipulators, with a total of
28 degrees of freedom, to collaboratively complete the task in
the shared workspace.
description might cause an infeasible motion planning result.
efficient ways to search the space of tasks [2, 3].
issues by integrating task and motion planning. The combi-
natorial complexity of TAMP can be partially mitigated if
the problem is properly formulated [46]. However, those
methods either scale poorly to complex, long-horizon tasks
or struggle with local minima due to the non-convex nature
of the problem. A recent study  introduced an innovative
framework that combines Linear Temporal Logic , as an
expressive specification language for long-horizon tasks, with
the Graph of Convex Sets (GCS) , a near-optimal motion
planner. This unified approach demonstrates scalability to
high-dimensional systems with up to 30 degrees of freedom.
extending it to multi-robot systems is challenging due to
the NP-hard nature of task allocation. Additionally, the LTL
specifications are computationally intensive. For instance, the
task of sequentially collecting five keys and opening five
doors in  required over 40 minutes, with 32 minutes dedi-
cated solely to handling the LTL specifications, reflecting the
double-exponential complexity inherent to this process. More
of handling such specifications. While their planning algorithm
claims to scale to scenarios involving up to 30 mobile robots
under hierarchical LTL specifications, it does not address
collision avoidance and collaboration among robots.
In this work, we address the problem of integrated task
and motion planning (TAMP) for multi-robot systems under
hierarchical temporal logic specifications, encompassing task
efficiency of hierarchical temporal logic specifications at the
task level and the Graph of Convex Sets (GCS) at the motion
ideas from , we formulate TAMP under hierarchical tempo-
ral logic specifications for multi-robot systems as a shortest-
path problem within a product graph. Our proposed approach
tackles several key challenges: converting hierarchical tempo-
ral logic specifications into a graph, addressing the task alloca-
tion complexities introduced by multiple robots, and efficiently
connecting nodes for multiple robots in the graph of convex
setsextending beyond the existing work  that deals with
at most two robots. The shortest-path problem in the product
graph is formulated as a mixed-integer convex programming
(MICP) problem, which can be efficiently solved using convex
relaxation techniques . We theoretically prove that our
approach is both sound and complete under mild assumptions,
and we empirically demonstrate its efficiency through case
studies involving four robotic manipulators. To manage the
complexity of the product graph, we implement a pruning
strategy based on the structure of the tasks. Additionally, we
extend the framework to scenarios involving multiple robotic
manipulators that require handovers, where the necessity for
handovers is not predetermined. The primary contributions of
this work are as follows:
1) We formulate the multi-robot hierarchical temporal logic
task and motion planning (TAMP) problem as a shortest-
path problem in a product graph.
2) At the task level, we construct a graph for hierarchical
temporal logic specifications and encompass the task
allocation within the edges. To construct the GCS at
the motion level, capturing the dynamics of multi-robot
efficiently connects the motion space.
3) We develop a heuristic to prune the product graph,
significantly improving the computational efficiency of
our method.
4) To address collaborative multi-robot pick-and-place tasks,
we adapt the product graph to incorporate handover
constraints and solve the shortest-path problem using
mixed-integer convex programming (MICP).
5) We provide theoretical analyses to prove the soundness
and completeness of our approach under mild assump-
6) We demonstrate the efficiency of our proposed method for
long-horizon tasks, complex task specifications, and high-
dimensional systems through several examples in both
simulation and hardware. Additionally, we provide open-
source code to reproduce our results.
The remainder of this paper is organized as follows. Section
II reviews related work on task and motion planning and
temporal logic specifications. Section III provides the back-
ground information on graphs of convex sets, linear temporal
problem and the underlying assumptions are presented in
Section IV. Our main approach to the problem is described
in Section V. Section VI offers proof of the soundness and
completeness of the proposed approach. The multi-robot task
and motion planning examples are described in Section VII.
provides the conclusion of our approach.
II. RELATED WORKS
A. Task and Motion Planning
The task and motion planning (TAMP) aims to identify a
sequence of symbolic actions and corresponding motion plans.
An extensive review of TAMP can be found in [12, 13].
TAMP typically focuses on single-robot scenarios. In this
task allocation is not applicable to a single robot. The primary
focus in multi-robot TAMP is on the pick-up and placement of
multiple objects by multiple manipulators, with the objective
of determining which manipulator should pick up which
objects and in what manner. One approach within this category
employs search-based methods. This includes Conflict Based
Search (CBS) , Monte-Carlo Tree Search (MCTS) ,
search in hyper-graphs , and search based on satisfiability
modulo theories (SMT) solvers . Another approach utilizes
optimization-based methods. For example,  proposed the
logic-geometric program (LGP), which integrates continuous
motion planning and discrete task specifications into opti-
mization problems. Similarly,  implicitly assigns actions
based on the solution to a nonlinear optimization problem. Our
work diverges from multi-robot TAMP in that most TAMP
studies do not consider logical or temporal constraints, with
only a handful addressing dependency constraints that emerge
from handover operations. Our approach incorporates these
B. Control Synthesis under Temporal Logic Specifications
Temporal logic specifications play various critical roles in
control synthesis, particularly within the realm of single-robot
systems. Primarily, temporal logic formulas are utilized to
define task specifications. For instance,  employs tempo-
ral logic to articulate temporally extended objectives and to
respond to failures during learning from demonstrations.
implement skill repair mechanisms when existing skills are
insufficient to satisfy LTL specifications. Similarly,  fo-
cuses on transferring skills across different LTL specifications.
Beyond task definition, temporal logic formulas are also
effective in representing constraints that dynamical systems
must adhere to. For instance,  introduces LTLDoG, a
diffusion-based policy for robot navigation that complies with
LTL constraints.  utilizes temporal logic to define dy-
namic constraints, ensuring the stability of walking trajectories
in bipedal robots. Additionally,  uses temporal logic to
impose constraints on switching protocols, enabling a single
agent to robustly track multiple targets.
In the realm of multi-robot systems governed by LTL
task specifications or constraints, LTL formulas are generally
categorized into local and global forms. One strategy, as
demonstrated in studies such as [2527], involves assigning
LTL tasks locally to each individual robot within the team.
the entire team. When global LTL specifications are employed,
they may either explicitly allocate tasks to specific robots [28
robots [3741]. This latter approach aligns with the problem
addressed in our current work.
Global specifications that do not explicitly assign tasks
to robots typically require decomposition to facilitate task
allocation. This decomposition can be achieved through three
primary methods: (a) The most common technique, used in
works such as [4251], involves breaking down a global
specification into multiple tasks by leveraging the transition
relations within the automaton, which graphically represents
an LTL formula. (b) As demonstrated in [38, 52], the second
approach utilizes BMC techniques  to develop a Boolean
Satisfaction or Integer Linear Programming (ILP) model. This
model simultaneously handles task allocation and implicitly
decomposes tasks within a unified framework. (c) The third
tree of LTL formulas to divide the global specification into
a hierarchical framework, where task allocation is determined
first followed by low-level plan synthesiswithout ensuring
the feasibility at the low levelor they employ a simultaneous
task allocation and planning approach to guarantee complete-
action models, which may be suitable for mobile robots but
are not applicable to robotic arms. In contrast, our work
distinguishes itself by performing simultaneous task allocation
and planning while directly considering continuous dynamics.
III. PRELIMINARY
{1, . . . , K} represent the set of integers from 1 to K, respec-
A. Linear Temporal Logic
Linear Temporal Logic (LTL)  is a type of formal logic
whose basic ingredients are a set of atomic propositions
temporal operators, next and until U. LTL formulas over
AP abide by the grammar
For brevity, we abstain from deriving other Boolean and
temporal operators, e.g., disjunction , implication , always
, eventually , which can be found in .
An infinite word  over the alphabet 2AP is defined as an
infinite sequence   01 . . . (2AP), where  denotes
an infinite repetition and k 2AP, k N. The language
Words()  {  } is defined as the set of words that
satisfy the LTL formula , where (2AP)   is the
satisfaction relation. In this work, we focus on a particular
subset of LTL formulas known as syntactically co-safe LTL, or
sc-LTL for short . As established by , any LTL formula
encompassing only the temporal operators and U and written
in positive normal form (where negation is exclusively before
atomic propositions) is classified under syntactically co-safe
formulas. Sc-LTL formulas can be satisfied by finite sequences
followed by infinite repetitions. This characteristic makes sc-
LTL apt for modeling and reasoning about systems with finite
LTL formula can be converted into a Deterministic Finite
Automaton (DFA).
Definition 3.1: (Deterministic Finite Automaton (DFA) )
A DFA A of a sc-LTL formula  over 2AP is defined as a
tuple A()
Q is the set of states;
2AP is an alphabet;
QQ is the transition relation with (q, ) 1
for all states q Q and all symbols  ;
q0 Q is the unique initial state;
QF Q is a set of accepting states.
A finite run  of A over a finite word   01 . . . h
is a sequence   q0q1 . . . qh1 such that (qi, i, qi1) ,
i  0, . . . , h. A run  is called accepting if qh1 QF .
The words  that produce an accepting run of A constitute
the accepted language of A, denoted by LA. Then  proves
that the accepted language of A is equivalent to the words of
, i.e., LA  Words().
B. Hierarchical sc-LTL
The work  incorporates a hierarchical structure into LTL
over finite traces. In this paper, we focus on hierarchical sc-
also be applied to sc-LTL.
Definition 3.2: (Hierarchical sc-LTL ) Hierarchical sc-
LTL is structured into K levels, labeled L1, . . . , LK, arranged
from the highest to the lowest. Each level Lk with k [K]
contains nk sc-LTL formulas. The hierarchical sc-LTL speci-
fication is represented as
k  k [K], i [nk]
k denotes the i-th sc-LTL formula at level Lk. Let k denote
the set of formulas at level Lk, and let Prop(i
k) represent the
set of propositions appearing in formula i
k. The hierarchical
sc-LTL follows these rules:
1) There is exactly one formula at the highest level: n1  1.
2) Each formula at level Lk consists either entirely of atomic
k) AP, or entirely of formu-
las from the next lower level, i.e., Prop(i
3) Each formula at level Lk1 appears in exactly one for-
mula at the next higher level: i
j[nk] Prop(j
and Prop(j1
k ) Prop(j2
k )  , for j1, j2 [nk] and
Example 1: (Hierarchical sc-LTL)
The following hierar-
chical sc-LTL specifications state that completing tasks a and
b and c, and c should not be the last one to be finished:
The symbol i
k is referred to as composite proposition if it is
inside a formula, and is referred to as specification otherwise.
Definition 3.3: (Specification hierarchy tree ) The spec-
ification hierarchy tree, denoted as Gh
(Vh, Eh), is a
tree where each node represents a specification within the
hierarchical sc-LTL, and an edge (u, v) indicates that specifi-
cation u contains specification v as a composite proposition.
Any hierarchical sc-LTL specifications can be turned into a
specification hierarchy tree.
A specification is termed as a leaf specification if the
associated node in the graph Gh does not have any children.
Let denote the set of leaf specifications. Note that not all
leaf specifications necessarily reside at level LK.
C. Shorest paths in Graphs of Convex Sets (GCS)
In this section, we introduce the shortest path formulation
in GCS. It is introduced in  and applied to robot motion
planning problems in . The goal is to find the minimum-
cost path from a start vertex to a target vertex in a graph.
defines a Graph of Convex Sets as a directed graph G  (V, E)
with vertices V and edges E. Each vertex v V is associated
with a convex set Sv and a point sv
e  (u, v) E is associated with a non-negative and convex
function le(su, sv) and a convex constraint (su, sv) Se. For
a fixed start vertex s and target vertex t, we are seeking a path
p as a sequence of vertices that connect the start vertex s and
t through the subset Ep of the edges E. Denoting the set of all
paths in the graph G as P, the shortest path problem in GCS
states as follows:
e(u,v)Ep
le(su, sv)
(su, sv) Se,
e  (u, v) Ep.
Although the shortest path problem (SPP) in the GCS is
formulation was proposed in . This MICP has a very tight
convex relaxation, meaning the optimal result can be tightly
approximated by the solution of the convex optimization. The
GCS has been further extended to robotic motion planning
around obstacles, as detailed in . The results demonstrate
that GCS is a robust trajectory optimization framework, capa-
ble of encoding various costs and constraints.
D. Convex Set (CS)-based Transition System
For simplicity, we assume that the configuration space
dimension for each robot is the same, denoted by d. For
a multi-robot system composed of n robots, the CS-based
transition system is defined as follows.
Definition 3.4: (CS-based Transition System) A CS-based
multi-robot transition system (TS) is defined as T
S Rnd represents the set of convex sets of configura-
tion states where all robots are guaranteed to be collision-
S  S is the transition relation, where (S, S)
if the sets S and S are either overlapping or adjacent.
two configuration states within the same convex set to
the same sets of labels, i.e., L(s)  L(s)  L(S) for
all S S and for any s, s S. With a slight abuse of
the convex set.
S is the convex set that includes the initial
configuration state (s0
Given the presence of multiple specifications in hierarchical
with a sc-LTL specification that a specific robot is executing.
Definition 3.5: (State-Specification
Sequence
state-specification sequence with a horizon h, represented
n)) is the collective state-
specification pairs of n robots at the i-th timestep, where
n) is the configuration state, and i
with  indicating the systems non-involvement in any leaf
specification at that time.
A state-specification sequence is considered to satisfy the
given hierarchical sc-LTL specifications if the root specifica-
1 is fulfilled; we refer the reader to  for further
details.
IV. PROBLEM FORMULATION
In this section, we introduce the problem formulation for
multi-robot hierarchical temporal logic task and motion plan-
Definition 4.1: (Trajectory) A trajectory for robot i defined
as i : R Rd is a function that maps any t R in time
to a robot configuration s Rd.
Problem 1: Consider a n-robot system with initial con-
figuration s0  (s0
n) Rnd, and hierarchical sc-
LTL specifications , the hierarchical temporal logic task and
motion planning problem requires finding the collision-free
robot trajectories   [1, . . . , n] with minimum-cost that
satisfy the hierarchical sc-LTL specifications. The planning
problem is shown as follows:
Trace()  ,
i(t) j(t)  ,
i(t) O  ,
i [n], t R,
where O represents obstacles, and Trace returns the trace of
trajectories by applying labeling function L to each state in
the trajectories .
We assume the cost J in (4a) is smooth and strictly convex.
It can be any convex function of trajectory . For example, the
cost can be the path length and include derivatives of states.
The first constraint (4b) ensures the trajectories satisfy the task
specification expressed as hierarchical sc-LTL specifications.
The second constraint (4c) and third constraint (4d) ensure
non-convex collision-avoidance constraints, requiring the robot
to avoid collisions with itself and the surrounding environment.
To deal with those non-convex collision-avoidance constraints,
inspired by trajectory optimization , we mitigate those
collision avoidance constraints by requiring the robot to move
through a collection of safe convex sets S1, S2, ... Rnd that
do not collide with obstacles. The last constraint (4e) imposes
initial conditions for each robot.
V. APPROACH
In this section, we present our approach to Problem 1. The
basic idea of our method involves several key steps: First,
we construct the labeled convex set regions in configuration
space to apply hierarchical sc-LTL specification to multi-robot
motion planning. To ensure the existence of a feasible path
between these convex set regions, we proposed a rapidly
exploring random tree (RRT)-guided method to construct
the connected convex set regions to connect those labeled
convex set regions. Using these convex sets and their labels,
Fig. 2: An architecture for hierarchical temporal logic task
and motion planning, where the transition system can be
precomputed offline.
Algorithm 1: Construct a labeled convex set
atomic proposition
convex set Slabel
1 slabel CalLabeledConfiguration() ;
2 Slabel IRIS-NP(plant, slabel) ;
3 return slabel, Slabel;
we then construct the CS-based transition system for multi-
each hierarchical sc-LTL formula into a Deterministic Finite
Automaton (DFA) and create a product graph by taking the
product of the CS-based transition system and the DFAs,
as described in Section V-B. Note that while our approach
can model robot collaboration and collision avoidance, these
aspects are not considered in . Next, to mitigate the
computational complexity associated with the potentially large
product graph, we implement a graph pruning technique to
simplify the problem based on task specifications, as outlined
in Section V-C. Finally, in Section V-D, we solve the pruned
product graph using the mixed integer convex program (MICP)
and extend our optimization framework to handle multi-robot
handover tasks. The overall architecture of our multi-robots
task and motion planning algorithm is illustrated in Fig. 2.
For a static environment, the CS-based transition system can
be precomputed offline, while the remaining modules are
computed online.
A. Construct CS-based Transition System for Multi-robots
To build a CS-based transition system defined in Def. 3.4,
we begin by constructing labeled convex sets, represented as
L(Slabel)  . Subsequently, given any two labeled convex sets
label and Sj
connect to establish a feasible pathway between
label and Sj
The process of constructing labeled convex sets, as outlined
in Alg. 1, proceeds as follows: Initially, for a multi-robot
system and a given atomic proposition , we compute a con-
figuration slabel that satisfies the specified atomic proposition
[line 1]. This configuration is typically determined through
robot inverse kinematics. Following this, we generate a labeled
convex set Slabel starting with slabel as the seed point, meaning
that this configuration is contained within the convex set.
Fig. 3: An example of generating the labeled convex region
for a multi-robot system. The atomic proposition is target a.
In Fig. 3(a), the atomic proposition  is used to compute
the labeled joint configuration slabel through robot inverse
kinematics. In this configuration, the bottom robot reaches
the position labeled as target a, while the configurations of
the remaining robots are unconstrained. Using slabel as a seed
that contains this seed point. The sampled configurations inside
the convex region are shown in Fig. 3(b). Note that not all
configurations of the bottom robot ensure reaching target a.
Fig. 3(c) illustrates the labeled convex region Slabel generated
by adding the bottom robots end-effector position constraints
in IRIS-NP algorithm, ensuring that all configurations in the
labeled convex region satisfy the atomic proposition target a.
Algorithm 2: IRIS-RRT
label and target configuration sj
1 path RRT(si
label) ;
connect IRIS-NP(plant, si
label) ;
4 while sj
label is not in convex sets Si,j
connect do
maximize
distancealongpath(sold
subject to snew
seed Si,j
connect and snew
seed path ;
Siris IRIS-NP(plant, snew
connect Si,j
connect {Siris} ;
seed snew
10 return Si,j
connect;
In this work, convex sets are constructed using the IRIS-NP
convex set is free from collisions. However, IRIS-NP does not
guarantee that every configuration in the convex set satisfies
the atomic proposition . To address this limitation, we
incorporate additional configuration constraints in the IRIS-NP
algorithm to ensure that all configurations within Slabel satisfy
the atomic proposition  [line 2]. An example of this algorithm
applied to a four-robot manipulator system is depicted in
Fig. 3. One such additional constraint is requiring a specific
robots end-effector to reach a designated position.
After generating the labeled convex sets S, we construct a
sequence of connected convex sets Si,j
connect to ensure connectiv-
ity between any two labeled convex sets, if possible. For high-
Fig. 4: A 2D example for collision-free convex set construc-
tion. The orange blocks represent obstacles. Given the robots
start configuration sstart and goal configuration starget, IRIS-
RRT algorithm uses RRT path (black line) as a guide to
approximate the connected convex sets to connect the start
and goal configurations. In the graph, sseedi represents the seed
configuration anchoring the i-th convex set, which is depicted
as a rectangle surrounded by dashed lines. Each pair of seed
configuration and its corresponding convex set is highlighted
in the same color. Note that the seed configurations typically
lie at the intersections of the path generated by RRT and the
previous convex sets. Moreover, the path generated by RRT
does not need to be smooth or optimal, as it primarily serves
to guide the construction of convex sets.
dimensional degree-of-freedom (DoF) multi-robot systems,
generating these connected convex regions randomly in the
robot configuration space might not successfully establish
connections between the labeled convex sets, and the optimal
solution might not traverse these convex sets. To address this
Alg. 2. Initially, Alg. 2 uses Rapidly-exploring Random Tree
(RRT) method  to find a feasible path between the two
labeled configurations [line 1]. Subsequently, it constructs a
set of connected convex sets along this path, spacing the seed
configuration states at maximum intervals along the feasible
path to minimize the number of connected convex sets [lines 4-
9]. To this end, starting with the initial configuration state
label is used to initialize Si,j
connect. The
next step involves identifying another configuration state along
the feasible path that is the farthest from si
label yet still within
connect. This configuration state then serves as a new seed,
and the process is iteratively continued to extend Si,j
connect until
it contains the goal configuration sj
label. Note that the RRT
method in Alg. 2 could be replaced by any motion planning
algorithm. A 2D example of the construction of convex sets
by IRIS-RRT is shown in Fig. 4.
B. Construct Product Automaton
In what follows, let (q, q) denote the propositional logic
formula that enables the transition from q to q in DFA. We
begin by addressing the challenge of constructing a graph,
referred to as the total product DFA, for hierarchical sc-LTL
specifications. First, for a set of specifications that have the
same level, we construct their product DFA.
Definition 5.1: (Product DFA (PDFA)) Consider a DFA
k ) of the i-th specification i
at level k. The PDFA for level k, denoted as Ak
(Qk, k, k, q0,k, QF
k ), is defined as follows:
k  . . .  Qnk
is the Cartesian product of
automaton states across the specifications at level Lk;
is the combined set of symbols
from all DFAs at this level, where i
k  2Prop(i
k is a non-leaf specification, representing the child
specifications of i
k at the immediate lower level k  1;
k QkkQk is the transition relation, where a tran-
k exists if (qi
k for all i [nk];
automaton;
. . .  QF,nk
is the set of accepting states.
Note that, by designing k to be the product of individual
transition occurs.
Definition 5.2: (Total PDFA (TPDFA))
The TPDFA A
(Q, , , q0, QF ) for hierarchical sc-LTL specifications is de-
tailed as follows:
Q  QK  . . .  Q1 represents the set of product states
across all levels;
K  . . .  1 denotes the set of symbols;
Q    Q defines the transition relation, where a
transition ((qK, . . . , q1), (K, . . . , 1), (q
is valid if:
(qk, k, q
k) k for each k [K];
k ) for all k [K], with i
k1 Prop(i
k1} if i
k is a non-
leaf specification, representing the child specifica-
tions of i
k at the immediate lower level k  1 that
are fulfilled given qk1; otherwise, i
q0  (q0,K, . . . , q0,1) is the initial product state;
QF  {q Q  q1
} is the set of accepting
product states where the root specification 1
1 is satisfied.
The transition relation in Def. 5.2 is constructed iteratively,
starting from the bottom level upwards. For leaf specifica-
whereas for non-leaf specifications, transitions are defined
by the truth of composite propositions from the immediately
lower level.
Example 1: continued (TPDFA) The corresponding DFAs
for each specification and the TPDFA for the hierarchical sc-
LTL specified in (2) are depicted in Fig. 5.
Definition 5.3: (Product Automaton (PA))
The product
automaton combining TPDFA and TS is denoted as P
(QP, P, P, qP,0, QF
P), where:
S  Q represents the set of product states,
combining the states of TS and TPDFA;
P   is the set of symbols used in the transitions;
P QP P QP is the transition relation, as defined
in Def. 5.5;
(d) TPDFA
Fig. 5: The DFAs corresponding to specifications have their
accepting states highlighted in yellow. In Fig. 5(d), only the
automaton states for leaf specifications are displayed since the
states of non-leaf specifications can be deduced from those
of the leaf specifications in a bottom-up manner. Within the
derived from two parts: the first component is from 1
2 and the
second from 2
2. There are four paths leading from the initial
state (init1, init1) to the accepting state (accept4, accept2).
be fulfilled.
LP  L is the labeling function that maps states to the
set of satisfied propositions;
initial state of TS with that of TPDFA;
P  S  QF is the set of accepting product states.
Before we detail the transition relation, we present how to
determine whether the observations LP(S), produced by n
) within m leaf specifications, where qi
the automaton state of the i-th leaf specification. This in-
corporates the task allocation into the edges of the product
automaton. The key idea is to verify whether it is possible to
construct  (1
) from LP(S) in a manner that
allows (q, , q
) as outlined in Def. 5.2.
Definition 5.4: (Model)
Given the set of atomic propo-
sitions LP(S) generated by n robots and the transition
within m leaf specifications, we deem LP(S) to
be a model of the propositional logic formulas (q, q
1) LP(S) does not falsify any propositional logic formula
), for i [m].
2) The leaf specifications are divided into two groups v
and  such that the total number of specifications
v    m, with v  v. Each group may
contain any number of specifications, including none.
3) The set of robots is partitioned into several groups
groups equals the total number of robots, Pv
R  n, and each group Ri and R can include zero
or multiple robots.
4) For each i [v], there is a one-to-one correspondence
between a leaf specification i
v and a group of
robots Ri, where the atomic propositions generated by
robots in Rimeet the propositional logic requirement
, expressed as LR(S)  i
). Here, LR(S)
represents the set of atomic propositions related to Ri.
In this case, i
5) Robots in R are not assigned any leaf specifications,
indicating they are idle.
6) There is no correspondence between any leaf specifica-
tion in  and any robots, meaning that currently, no
robots are engaged with the specifications in , but the
propositional logic for each specification in  can be
trivially fulfilled by . In this case, i
Condition 1) requires that no leaf specification is violated by
the joint robot configuration. Condition 2) categorizes robots
into those actively executing tasks and those not assigned to
any task. Similarly, Condition 3) classifies tasks into those
currently being performed by robots and those temporarily on
hold. Condition 4) connects robots actively executing tasks
and tasks currently being performed, allowing for scenarios
where multiple robots collaborate on a single task, such as
jointly carrying a heavy load. Conditions 5) and 6) pertain to
situations involving idle robots and tasks that are not currently
assigned to any robot, respectively.
Definition 5.5: (Transition Relation) A transition from one
product state qP  (S, q) to another q
P  (S, q) occurs if
the following conditions are satisfied:
(S, S) , as specified in Def. 3.4;
The set of propositions LP(S) is a model of the transition
), as outlined in Def. 5.4, indicating that the
observed propositions at S satisfy the transitions at the
leaf specifications.
For each level k from 1 to K, the transition (qk, k, q
C. Prune PA
To manage the large size of the PA and facilitate the
optimization process, we implement pruning techniques to
Algorithm 3: Construct essential PA
P GetEssentialStates(QP, P) ;
P QP {qP,0} QF
4 for qP  (S, q) Q
P  (S, q) Q
if q q then
Sconnect IRISRRT(S, S) ;
P  (S, q) QP  S
P  GetTransitions(P, Qe
10 return Pe  (Qe
reduce its complexity.
Definition 5.6: (Essential State) Given a pair of transitions
P where qP  (S, q) and q
P  (S, q), the product
state qP is defined as an essential state if the automaton states
An essential state marks that there has been progress at
the task level. Based on this concept, the specifics of the
pruning process are detailed in Alg. 3. The procedure starts by
expanding the set of essential states to include both the initial
and accepting states [lines 1-2]. Using these essential states
as the product space skeleton, we then establish connections
between each pair of essential states where possible, utilizing
intermediate states that navigate the robots through their
configuration states according to a path determined by the RRT
[lines 7-8].
D. Optimization Formulation and Extension for Multi-robot
Handover
Upon building the product automaton P, we define a target
product state qtarget
, which serves as the endpoint for all
accepting product states within QF
P. The graph of the product
optimization problem by focusing exclusively on the configu-
ration aspect of the product states, as the automaton aspect of
the product states shapes the graph structure. This approach
effectively transforms the problem into motion planning in the
configuration space . The initial configuration state is de-
rived from the initial product state, and the target configuration
state corresponds to qtarget
. This setup is tackled through an
optimization problem formulated with convex programming
as shown in equation (3), aiming to establish a viable path
from the initial to the target configuration states. In what fol-
pick-and-place tasks, which include handover interactions, by
introducing relevant constraints.
Consider a scenario with l objects. We define binary de-
cision variables bi,j to indicate whether robot i holds object
When bi,j
object j. In contrast, bi,j
0 indicates that the robot i
is not engaged in transporting the object j. The handover
constraints governing the transfer of objects between robots
are categorized into three types: incoming constraints, conflict
1) Incoming Constraints: Incoming constraints depict sce-
narios in which robots transport objects to various (interme-
diate) locations. For any given vertex v V, these constraints
depend on whether the robot i, for each i [n], is engaged in
a handover with another robot. There are two possible cases
for incoming constraints:
(a) Robot i is not conducting the handover. This scenario
is governed by an equality constraint that ensures the conti-
nuity of possession, meaning object j remains with robot i
during transit when no handover occurs:
leading into the vertex v.
It should be noted that if the optimal path in the product
graph does not traverse certain vertices, the binary decision
variables associated with those vertices, bi,j
and the incoming constraint (5) becomes irrelevant. To ensure
that the incoming constraint is only applied along the optimal
path includes the edge from v to v . We adopt the Big-M
method to establish a connection between the optimal path
and the binary decision variable bi,j
v . The revised form of
the incoming constraint (5), when robot i is not engaged in
handover within the vertex v, is expressed as follows:
M(ye 1) (bi,j
v ) M(1 ye),
where M is typically a large positive integer. We set M  2
to ensure a tighter formulation.
(b) Robot i is conducting the handover. Assume i,
where i [n], is the robot with which the handover is
being conducted. The following constraint ensures that the two
robots successfully transfer object j, j [l], upon reaching
the location by toggling the decision variables associated with
each robot at the respective vertices:
To ensure that the incoming constraint (7) for robot han-
dovers is applied strictly along the optimal path, we utilize
the Big-M method to reformulate the handover constraint for
robot i in the vertex v as follows:
M(ye 1) (bi,j
v ) M(1 ye),
The constraint (8) effectively prevents a handover from occur-
ring unless the path is optimal.
2) Conflict Constraints: To ensure that each robot handles
no more than one object at a time, and each object is managed
by only one robot simultaneously, the following constraints
v V, i [n],
v V, j [l].
3) Labeled Convex Set Constraints: For a product automa-
ton P associated with labeled convex set that is labeled with
a robot, denote by i, whose state aligns with the location of
object j and the vertex v V:
Those handover constraints ensure an orderly and conflict-
free transfer of objects among the robots. Due to the involve-
ment of binary decision variables in the handover constraints,
we solve the optimization Problem 1 using mixed-integer
convex programming (MICP).
VI. THEORETICAL ANALYSIS
Theorem 6.1: (Soundness) The returned path p satisfies the
hierarchical sc-LTL specifications .
we construct a state-specification sequence  as in Def. 3.5
from the path p. In the second step, we prove that the state-
specification sequence  satisfies the hierarchical sc-LTL .
To obtain the state-specification sequence , the goal is to
pair each robot with a leaf specification that it is undertaking, if
any. Note that each point in the path p is a product state q com-
posed of a configuration state s  (s1, . . . , sn) and a product
DFA state qP  (qK, . . . , q1) with q (q1
) for leaf
specifications. Let q
1) with q
denote the next state of qP in the path p. As stated in Def. 5.5,
LP(S) is a model of (q, q
). Next, we analyze depending on
conditions in Def. 5.4. Specifically, condition 1) ensures that
no leaf specification is violated. Furthermore, we pair the leaf
specification i
v with every robot in the corresponding
set Ri, according to condition 4), otherwise, we pair robot
i R with null specification  according to condition 5).
Given the state-specification sequence , the labels gener-
ated by the sequence of configuration states satisfy not only
the leaf specifications, but also the non-leaf specifications,
according to the transition relation in Def. 5.5,. Moreover,
it reaches an accepting product state where the top-most
specification 1
1 is satisfied, implying that the hierarchical sc-
LTL is satisfied according to semantics in .
Definition 6.2: (Incompatible specifications) Two sc-LTL
specifications are considered incompatible if there exists a path
that satisfies one but inevitably violates the other, regardless
of how the path is extended.
For instance, 1  a and 2  a U b are incompatible,
as a path that produces label a but not label b satisfies 1 while
violating 2. This path cannot be extended to satisfy 2. We
say that a hierarchical sc-LTL specification  is considered
compatible if it does not include any pair of leaf specifications
that are mutually incompatible.
Theorem 6.3: (Completeness) Assuming the hierarchical
sc-LTL  is compatible, up to the space decomposition and
trajectory parameterization, our approach returns a path that
satisfies .
encompasses all possible behaviors of the robot system, while
the total product of DFAs encompasses all solutions to fulfill
the hierarchical sc-LTL (Def. 5.2). The construction of PA
(Def. 5.3) is based on the concept of a model (Def. 5.4). In
that contradict each other. Since we consider only compatible
hierarchical sc-LTL specifications, no contradictory proposi-
tional logic formulas arise. Conditions 2)-6) ensure the exis-
tence of a feasible task allocation. Consequently, the product
system (Def. 5.3) includes all behaviors of the robot system
that conform to the hierarchical sc-LTL. According to , by
increasing the number of convex sets and the degree of Bzier
curves to enhance the approximation, the MICP is guaranteed
to find a path.
VII. EXPERIMENTS
We evaluate our approach across a variety of multi-robot
task scenarios, including planar robot motion planning,
coordination
multiple
manipulators
several robots and a conveyor system. All experiments
were conducted using the Drake , and executed on
a desktop computer equipped with an Intel i9 processor
Mixed-Integer
Programming
interface.
open-source
accessed
labTaskMotionPlanningwithHLTLandGCS.git.
running times for the algorithm of all scenarios are detailed
in Table I. We precompute the CS-based transition system
offline and report computation times for online modules,
including PA construction, PA pruning, and MICP solving.
The demonstration video is available at this link.
A. Planar Motion Planning Case
The planar motion planning scenario depicted in Fig. 6
involves a robot tasked with collecting five keys to navi-
gate through the corresponding doors. This benchmark ex-
, originally required transforming the sc-LTL formula into
DFA. The conversion process from sc-LTL to DFA is known
to exhibit double-exponential complexity , leading to a
prolonged conversion time. By employing hierarchical sc-
original standard sc-LTL formula is
doori U keyi goal.
The hierarchical sc-LTL specifications are represented as
2  doori U keyi,
2  goal.
Fig. 6: The door puzzle problem, where the blue dot represents
the initial robot location. [7, 61].
Hierarchical sc-LTL enhances the efficiency of representing
temporal logic specifications, resulting in quicker conversion
times and faster motion planning. This improved efficiency
is evident in the performance comparison shown in Table II.
Our approach yields a solution with a cost almost identical to
that of the method described in , yet it achieves this result
approximately 40 times faster.
B. Multi-robot Motion Planning and Handover Case
To illustrate the scalability of our method in high-
dimensional spaces, we evaluated it in four systems with
different tasks: a system involving two robotic manipulators
(Fig. 7), a system with four robotic manipulators with multiple
objects(Figs. 8-10), a system with robotic manipulators and
mobile robots (Fig. 11), and a structured industrial environ-
ments with robotic manipulators and conveyor (Fig. 12).
1) Two robotic manipulators: In the initial example, two
robotic manipulators are tasked to pick up an object from
target 1 and place it on target 2. The hierarchical sc-LTL
specifications for this scenario are articulated as follows:
2  (target1 target2).
Our planning algorithm uses Bzier splines to navigate a
valid path, ensuring C2 continuity for smooth trajectories. An
L2 norm for the length of the joint path is also integrated
to optimize for the shortest possible route. We evaluate our
planner in two distinct pick-and-place scenarios. In the first
equidistant from both robots, our planner decides only the
TABLE I: Algorithm Running Time.
Construct PA (s)
Prune PA (s)
Solver Time (s)
two-robot motion planning
two-robot handover
four-robot handover (scenario 1)
four-robot handover (scenario 2)
four-robot handover with obstacle (scenario 3)
four-robot handover (scenario 4)
Spot-robot handover
two-robots with conveyor
Time (s)
Sc-LTL to DFA
Construct PA
TABLE II: Performance comparison.
robot with the shortest path to execute the task, leaving the
other robot stationary to minimize the total path length. In
the second scenario, illustrated in Fig. 7(b), each robot ex-
clusively accesses one of the targets, necessitating a handover
to complete the task. Consequently, one robot picks up the
object and passes it to the other, which then places it at target
2. These tests confirm that our planner adeptly identifies the
most efficient strategy autonomously, eliminating the need for
pre-defined orders on robot movement or handover timing.
2) Four robotic manipulators with multiple objects: The
second example shows our planner in a more complex scenario
and task specification that involves four KUKA iiwa robotic
evaluated our algorithm in several distinct scenarios to assess
its performance under different task specifications.
a) Scenario 1: In the first scenario, the robot was aligned
in a linear arrangement, illustrated in Fig. 1. The robots are
assigned to pick up three objects from specifically labeled
pickup positions (targets 1, 2, and 3) and place them in
corresponding placement positions (targets 4, 5, and 6). The
hierarchical sc-LTL specification for this task is given by:
2  (target1 target4)
2  (target2 target5)
2  (target3 target6),
which states that the robot should pick up movable objects
from targets regions 1, 2, and 3, and place them in regions
take into account the interactions between the gripper and
the robot trajectory. Instead, the focus of our planner is on
identifying a collision-free path in the configuration space that
satisfies the hierarchical sc-LTL specifications within a 28-
DOF system. This is a benchmark example proposed in .
The problem was solved by nonlinear trajectory optimization
with smoothed discrete variables, solving multi-robot handover
(a) Both robots can reach the target positions 1 and 2.
(b) The left robot can only reach target 1, and the right robot can only reach
target 2. The handover is necessary to complete the task
