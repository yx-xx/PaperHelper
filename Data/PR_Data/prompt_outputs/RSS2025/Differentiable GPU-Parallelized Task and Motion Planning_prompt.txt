=== PDF文件: Differentiable GPU-Parallelized Task and Motion Planning.pdf ===
=== 时间: 2025-07-22 09:42:47.638432 ===

请你只输出如下JSON，所有字段都必须有，且每个“关键词”字段只允许输出一个中文词语（不能是英文，不能是多个，不能是短语，不能有逗号、分号、空格），否则视为不合格。不要输出任何解释或正文，只输出JSON。
{
  "论文标题": "",
  "研究主题关键词": "",
  "应用场景关键词": "",
  "主要方法关键词": "",
  "创新点关键词": "",
  "主要结论关键词": ""
}
内容：Differentiable GPU-Parallelized
Task and Motion Planning
William Shen1,2, Caelan Garrett2, Nishanth Kumar1,2, Ankit Goyal2, Tucker Hermans2,3,
Leslie Pack Kaelbling1, Tomas Lozano-Perez1, Fabio Ramos2,4
1MIT CSAIL, 2NVIDIA Research, 3University of Utah, 4University of Sydney
Plan Skeleton
Evaluate
Cost Functions
Particle
Initialization
Initial State
Optimized Goal State
Gradient-Based
Optimization
parameters
constraints  plan costs
updated particles
Step 100
Step 800
Step 1200
Batch of
Particles
gradients
cuTAMP Overview. cuTAMP frames TAMP as a backtracking bilevel search over plan skeletons (Sec. IV). Each
skeleton  induces a continuous Constraint Satisfaction Problem that defines the structure of a particle (parameters) and cost
functions (constraints and plan costs). These particles are optimized in parallel by evaluating their costs with differentiable
cost functions (Eq. 4), allowing gradient-based optimizers to iteratively update them towards satisfying solutions (Sec. V-B).
AbstractPlanning long-horizon robot manipulation requires
making discrete decisions about which objects to interact with
and continuous decisions about how to interact with them. A
robot planner must select grasps, placements, and motions that
are feasible and safe. This class of problems falls under Task and
Motion Planning (TAMP) and poses significant computational
challenges in terms of algorithm runtime and solution quality,
particularly when the solution space is highly constrained. To ad-
dress these challenges, we propose a new bilevel TAMP algorithm
that leverages GPU parallelism to efficiently explore thousands
of candidate continuous solutions simultaneously. Our approach
uses GPU parallelism to sample an initial batch of solution seeds
for a plan skeleton and to apply differentiable optimization on
this batch to satisfy plan constraints and minimize solution cost
with respect to soft objectives. We demonstrate that our algorithm
can effectively solve highly constrained problems with non-convex
constraints in just seconds, substantially outperforming serial
TAMP approaches, and validate our approach on multiple real-
world robots. Project website and code: cutamp.github.io
I. INTRODUCTION
Task and Motion Planning (TAMP) enables robots to plan
long-horizon manipulation through integrated reasoning about
sequences of discrete action types, such as pick, place, or
strated remarkable generality in complex tasks including ob-
ject rearrangement , multi-arm assembly , and cooking
Work partially conducted during internship at NVIDIA. Correspondence
a meal . However, TAMP problems become increasingly
challenging to solve efficiently as the horizon and action space
tightly interacting constraints, e.g., kinematics and collisions.
A popular family of TAMP algorithms solve problems by
first searching over discrete action sequences, also known as
plan skeletons, and then searching for continuous action pa-
rameter values that satisfy the collective action constraints that
govern legal parameter values. Each candidate plan skeleton
induces a continuous Constraint Satisfaction Problem (CSP),
which TAMP algorithms typically solve using a mixture of
compositional sampling and joint optimization techniques,
with each having their own trade-offs .
Sampling-based approaches to TAMP disconnect the pa-
rameters by generating samples for each independently using
hand-engineered [5, 6, 7], projection-based , or learned
generators [9, 10], and then combining them through com-
position and rejection. Because the parameters only interact
through rejection sampling when evaluating constraints, many
samples are often needed to satisfy problems where the
constraints interact, such as tight packing problems (Figure 1).
Optimization-based TAMP approaches, on the other hand,
represent constraints as analytic functions in a mathematical
program and solve for the continuous parameters by applying
first- or second-order gradient descent [1, 11]. However, these
constrained mathematical programs are highly non-convex
with many local optima, making it challenging to find even
a feasible solution from random parameter initializations.
Place Yellow
Place Red
Place Green
Goal State
Fig. 3: Object Packing with a UR5. The objective is to
place all objects onto the white region while minimizing
the distance between them. The final state achieves a tight
packing with successful reduction of the goal cost.
Pick Mustard Bottle
Place Canister
Place Red Block
Fig. 4: Block Stacking with a Kinova Arm. The objective is
to stack the red block on the blue block. However, the mustard
bottle and canister obstruct all placements. cuTAMP reasons to
move these objects out of the way before placing the red block.
We present cuTAMP, the first GPU-parallelized TAMP
planner. cuTAMP enables massively parallel exploration of
TAMP solutions by combining ideas from sampling-based
and optimization-based TAMP with GPU acceleration, going
beyond prior serial algorithms. We treat TAMP constraint
satisfaction as simultaneous differentiable optimization over
a batch of particles, representing thousands of candidate
solutions. This allows us to maintain the interdependence
between continuous parameters by jointly optimizing them.
To initialize the particles, we leverage parallelized samplers
that solve constraint subgraphs, composing their generations
to populate particles near the solution manifold while ensuring
good coverage of parameter space. We demonstrate that when
massively parallelized, cuTAMP can effectively solve highly
constrained TAMP problems. Our approach inherits the local-
ity of gradient descent and explores multiple basins through
compositional sampling, increasing the likelihood of finding
the global optima. Although we focus on GPU acceleration,
our method applies to other forms of parallel computation.
We evaluate cuTAMP on a diverse range of TAMP prob-
lems of varying difficulty and highlight the benefits of GPU
parallelism. By scaling the number of particles, we achieve
significant improvements in the number of satisfying solutions,
algorithm runtime, and solution quality. For highly constrained
problems that baselines fail to solve, cuTAMP finds solutions
in just seconds. We deploy our algorithm on a real UR5 and
Kinova arm and showcase its fast planning capabilities for
long-horizon manipulation problems (Figures 3 and 4). Code
and videos are available on our website: cutamp.github.io.
II. RELATED WORK
Parallelized Motion Planning. Early algorithms for par-
allelized motion planning used multiprocessing  during
primarily embarrassingly parallelizable operations, for exam-
configuration space . More recent algorithms leverage
vectorization  or GPU-acceleration [15, 16] to implement
primitive motion planning operations, such as forward kine-
matics and collision checking. Our work is most closely related
to cuRobo , which leverages GPU-acceleration in two
(PRM)  phase that generates candidate paths, and second,
during a trajectory optimization phase seeded from these paths
that minimizes trajectory duration subject to dynamical limits.
In contrast, cuTAMP addresses the broader problem of TAMP
(i.e., manipulation planning), which requires reasoning about
Sampling-Based
TAMP. Sampling-based TAMP algo-
rithms handle the continuous decision-making within TAMP
through discretization and composition. They generate values
that satisfy specific constraints, such as grasp and placement
stability constraints, and intersect them with additional con-
rejection and conditional sampling . Prior approaches do
this by sampling a fixed problem discretization [19, 20], com-
bining generators using a custom interface layer , searching
through the multi-modal continuous space [21, 8], specifying
geometric suggesters , and composing samplers using a
stream specification [7, 2, 22, 23]. Additionally, it is possible
to cast satisfaction as an inference problem and leverage
techniques like Markov chain Monte Carlo (MCMC)  and
Stein Variational Inference . We leverage sampling to pop-
ulate candidate particles that are near the solution manifold,
but not necessarily feasible, for gradient-based optimization.
Optimization-Based
TAMP. In contrast to sampling-
based algorithms, which leverage constraint compositional-
continuous parameters that jointly satisfy all plan constraints.
Although sampling-based methods can generally optimize
plan cost in an anytime mode using rejection sampling,
optimization-based TAMP leverages mathematical program-
eral approaches use off-the-shelf Mixed Integer Programming
(MIP) solvers for constraint satisfaction; however, these ap-
proaches are limited to simplified TAMP problems where
the continuous dynamics are linear [26, 27] or convex [28,
convex constrained optimization problem using Sequential
Quadratic Programming (SQP) , Augmented Lagrangian
methods [33, 34, 35, 26, 36, 37], and Alternating Direction
Method of Multipliers (ADMM) . These methods are
computationally expensive per attempt and are not guaranteed
MoveFree(q1, q2 : conf,  : traj)
Pick(o : obj, g : grasp, p : placement, q : conf)
MoveHold(o : obj, g : grasp, q1, q2 : conf,  : traj)
Place(o : obj, g : grasp, p : placement, s : surface, q : conf)
Listing 1: Parametrized actions for pick and place tasks.
We list the most important constraints for simplicity of pre-
sentation. CFree is an abbreviation for Collision Free.
to converge to a feasible solution. By optimizing thousands of
candidates solutions in parallel, our approach is more likely
to produce at least one feasible solution.
III. PROBLEM FORMULATION
Our approach is generally applicable to long-horizon
decision-making problems with both discrete and continu-
ous parameters, such as assembly line design, smart power
grid management, and programming video game non-playable
characters. We focus on solving TAMP problems.
Let a TAMP problem be a tuple   A, s0, S, where
A is a set of parametrized actions, s0 is the initial state,
and Sis the set o
