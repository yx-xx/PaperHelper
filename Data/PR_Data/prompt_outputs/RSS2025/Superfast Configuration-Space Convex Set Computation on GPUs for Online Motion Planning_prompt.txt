=== PDF文件: Superfast Configuration-Space Convex Set Computation on GPUs for Online Motion Planning.pdf ===
=== 时间: 2025-07-22 15:42:11.469153 ===

请你只输出如下JSON，所有字段都必须有，且每个“关键词”字段只允许输出一个最核心的最有代表性的中文关键词（不能是英文，不能是多个，不能有逗号、分号、空格），否则视为不合格。不要输出任何解释或正文，只输出JSON。
{
  "论文标题": "",
  "研究主题关键词": "",
  "应用场景关键词": "",
  "主要方法关键词": "",
  "创新点关键词": "",
  "主要结论关键词": ""
}
内容：Superfast Configuration-Space Convex Set
Computation on GPUs for Online Motion Planning
Peter Werner1, Richard Cheng2, Thomas Stewart3, Russ Tedrake1,2, and Daniela Rus1
1MIT CSAIL 2Toyota Research Institute 3Woven by Toyota
{wernerpe, russt, rus}mit.edu
richard.chengtri.global, tom.stewartwoven.toyota
AbstractIn this work, we leverage GPUs to construct
probabilistically collision-free convex sets in robot configuration
space on the fly. This extends the use of modern motion planning
algorithms
leverage
representations
changing
environments. These planners rapidly and reliably optimize high-
quality trajectories, without the burden of challenging nonconvex
collision-avoidance constraints. We present an algorithm that
inflates collision-free piecewise linear paths into sequences
of convex sets (SCS) that are probabilistically collision-free
using massive parallelism. We then integrate this algorithm
into a motion planning pipeline, which leverages dynamic
roadmaps to rapidly find one or multiple collision-free paths,
and inflates them. We then optimize the trajectory through
the probabilistically collision-free sets, simultaneously using
candidate
trajectory
collisions
from the sets. We demonstrate the efficacy of our approach
simulation
benchmark
manipulator with perception in the loop. On our benchmark,
our approach runs 17.1 times faster and yields a 27.9
increase in reliability over the nonlinear trajectory optimization
I. INTRODUCTION
Finding high-quality collision-free motion plans remains
one of the most fundamental and challenging problems in
robotics [1, 2]. Systems with high demands on reliability
and performance, e.g. on production lines or in warehouses,
often require carefully tailored ad hoc solutions, which afford
reliability at the cost of engineering effort and performance.
Over the years, sampling-based motion planning, trajectory
optimization using nonlinear programming, and combinations
motion planning. Sampling-based motion planners are simple
to implement [2, 3], work well in lower dimensions, can have
completeness guarantees, and can be massively accelerated
using large-scale parallelization [4, 5]. See  for an overview
on sampling-based motion planning. Unfortunately, these
methods become impractical as the dimension increases,
yielding suboptimal motion plans and long planning times.
Directly transcribing motion planning as a general nonlinear
optimization
solutions
dimensional problems and allowing the user to encode a wider
variety of costs and constraints. Unfortunately, such local
optimization approaches are sensitive to initialization and often
struggle to find a feasible solution when one exists.
To capture the strengths of both trajectory optimization and
sampling-based motion planning, a series of recent works [10
17] initially proposed in  investigate planning through
collections of collision-free convex sets that approximately
decompose the free space. For the remainder of this paper,
we will refer to this class of planners as decomposition-
based motion planners (DBMPs). A challenging nonconvexity
in trajectory optimization stems from the collision-avoidance
constraints. Given a collection of collision-free convex sets,
DBMPs replace these nonconvex constraints with simple
convex constraints, which allows them to profit from the
fast solve times and reliability of convex optimization. This
shifts the challenges that stem from these collision-avoidance
constraints to constructing a high-quality representation of the
collision-free space through a union of convex sets.
For a candidate approximate convex decomposition to be
high-quality trajectories in the union of the sets, and its
individual sets should be described by few constraints in order
to keep the trajectory optimization problems small.
Many robot motion planning problems are most naturally
formulated in the robots configuration space C. Therefore,
we seek to construct the convex sets in Cfree, the collision-
free subset of C. Unfortunately, this is particularly challenging
because configuration spaces tend to be high-dimensional
complicated
often only
implicit descriptions of Cfree [1, 4.3.3]. Therefore, the go-
to algorithms used by practitioners for constructing convex
decompositions of Cfree are slow, scale poorly with the
environment complexity, and are difficult to use [19, 20],
mainly due to their complexity or because they are difficult
to tune. Additionally, these algorithms only consider static
environments. Generally, the sets need to be recomputed
in case the environment changes. So far, these challenges
have made set construction a bottleneck, and have prevented
DBMPs from being applied successfully to scenarios involving
changing environments like mobile manipulation.
In this paper, our aim is to tackle two key challenges: (1)
computing convex sets in robot configuration space for motion
planning in real-time, and (2) reliable and effective positioning
of the sets such that they contain high-quality trajectories.
By addressing these challenges, our aim is to unlock the
benefits of DBMPs and enable their use in general, changing
environments.
Fig. 1: On the left, our hardware setup with a KUKA LBR iiwa 7 R800 robotic manipulator and three Intel RealSense D415
depth cameras for perceiving obstacles is shown. In the center, the simulated system with the perceived obstacles is shown.
The target end effector pose is indicated by the yellow gripper and the collision geometries of the system are shown in red.
The perceived obstacles are approximated by a union of spheres shown in the center of the table. The figure on the right shows
a two-dimensional slice of the seven-dimensional configuration space, along with a slice of the safe sets (blue and green), and
a slice of the configuration obstacles (self-collisions in black, collisions with perceived obstacles in red). The slice lies tangent
to the trajectory such that the u-direction is co-linear with the velocity and the v-direction is a random orthogonal vector. The
current configuration is indicated by the black dot.
To tackle challenge (1), we build on the recently developed
IRIS-ZO algorithm , which lends itself to large-scale
parallelism. In particular, we propose Zero-Order Edge
Inflation (EI-ZO), and demonstrate that GPU acceleration of
our algorithm enables real-time set construction in changing
configuration spaces.
EI-ZO also addresses challenge (2) by inflating collision-
free line segments rather than points, yielding probabilistically
collision-free polytopes which are guaranteed to contain the
seed line segment. This enables us to inflate collision-free,
piecewise-linear (PWL) paths between the start and the goal
into sequences of convex sets (SCS) in which successive sets in
the sequence intersect. By construction, this SCS connects the
start to the goal and guarantees the containment of a collision-
free path. In comparison to approximating the entire free space
with a union of convex sets , this approach dramatically
reduces the computational burden by reducing the number of
required sets. Perhaps more importantly, it makes the step of
finding a collection of sets that connect the start to the goal
combines these ideas with large-scale dynamic road maps
(DRMs). The pipeline first leverages the DRM to rapidly find
a collision-free PWL path from a starting configuration to a
goal configuration. Next, this path is inflated with EI-ZO to
produce a SCS, which is then used to recover high-quality
motion plans using DBMPs.
We demonstrate the efficacy of our approach in simulation
benchmarks in two and seven dimensions and validate the
approach on hardware using a KUKA iiwa with perception
in the loop, as shown in Fig. 1. Relative to the nonlinear
trajectory
optimization
approach
produces
slightly higher-cost trajectories, but increases the success rate
from around 72 to 100 on our simulation benchmark,
while computing trajectories around 17 times faster.
The remainder of this paper is structured as follows. In
II we outline the assumptions and required inputs. Next, we
review prior work on constructing convex sets in configuration
space for motion planning in III. Our algorithm, EI-ZO, for
inflating line segments in configuration space is then presented
in IV. We outline how we employ DRMs in V. We then
present our full motion planning pipeline combining DRMs,
VII. In VIII we discuss the limitations and in IX draw a
conclusion.
II. ASSUMPTIONS
We make similar assumptions as in prior work on computing
approximate convex decompositions of Cfree, e.g. [21, 2].
That is, we assume that we are given a description of the
considered robot system which contains information about the
kinematics and collision geometries of the system sufficient for
collision checking, e.g. as provided in URDFs  or SDFs
. If we are dealing with additional obstacles entering and
leaving the system, then we assume that (1) these obstacles
remain static during the brief planning and execution time
of the motion plan and (2) we are given observations of
the obstacles sufficient to perform (potentially conservative)
collision checks against them. Specifically, we assume that
our collision checker never mislabels a configuration as safe
when it is actually in collision.
III. BACKGROUND
A. Constructing Safe Sets in Robot Configuration Space
The construction of convex safe sets in robot configuration
space has been studied in [1921]. The algorithms in
compute provably collision-free polytopes in a rational
reparametrization of the configuration space using polynomial
optimization. Due to the high computational cost of the
approaches in , we direct our focus towards the algorithm
extended to IRIS-NP2 and IRIS-ZO in . These algorithms
leverage nonlinear optimization to compute probabilistically
collision-free polytopes in robot configuration space in
substantially less time. IRIS-NP2 and IRIS-ZO provide a
probabilistic guarantee for a produced polytope P of the form
(P  Cfree)
which controls what fraction of the volume of P is allowed
to be in collision. In (1),  denotes the Lebesgue measure in
allowed to be in collision, and  is the admissible uncertainty.
Here we introduce an algorithm for constructing safe
sets around line segments that primarily builds on IRIS-ZO
[21, 5.2]. IRIS-ZO constructs probabilistically collision-free
polytopes by iteratively removing collisions from the current
region via hyperplanes. It optimizes the locations of these
hyperplanes using sampling and collision checking. We build
on IRIS-ZO because it only relies on collision checking and
simple sample updates, making it massively parallelizeable,
and amenable to GPU acceleration.
B. Positioning Safe Sets for Effective Motion Planning
There have been two approaches to position individual
convex sets for motion planning. The first approach is to find a
collection of convex sets that efficiently cover a large fraction
of the entire configuration space. The second is to only cover
an individual collision-free (but potentially suboptimal) path.
For example, in [22, 25], visibility graphs are used to
construct approximate convex covers which try to minimize
the number of polytopes required to meet a coverage threshold.
The approach in  uses densely sampled visibility graphs
and visibility kernels in two and three dimensions to construct
a cover of polytopes represented as convex hulls of samples.
The Visibility Clique Cover algorithm in  works in
higher dimensions by expanding cliques on visibility graphs
to probabilistically collision-free polytopes using an algorithm
similar to .
relatively
required number of sets is already prohibitively large for
online cover generation. Instead, we focus on the second
suboptimal) path with collision-free convex sets.
This strategy has been investigated in two and three-
dimensional task spaces to generate safe flight corridors on the
fly [1214, 26], where either a sequence of boxes is computed
, or the IRIS algorithm  is modified to include line
segments of a collision-free path [13, 14, 26] in the produced
polytopes. In [13, 14], this is accomplished by careful selection
of the initial ellipsoid, which defines the distance metric in the
IRIS algorithm for optimizing hyperplane placement. A more
involved formulation is used in  that admits constraining
the inclusion of line segments directly in the optimization of
the hyperplanes.
In general, this second strategy has the advantage of
only generating regions relevant for the current planning
dimensional configuration spaces. Our approach proposes a
simple modification to the IRIS algorithms: using the distance
to a line segment as a metric instead of one defined by an
ellipsoid. As discussed in IV, this guarantees the inclusion of
the line segment (provided it is collision-free), skips checking
the ellipsoids for collisions, and avoids the more involved
optimization problems in , which would not be amenable
for GPU implementation.
IV. RAPIDLY INFLATING LINE SEGMENTS
In this section, we discuss our algorithm, Edge Inflation
Zero-Order (EI-ZO), for rapidly inflating line segments to full-
configuration space using only zero-th order information about
the system. First, we observe that the distance to a convex set,
in particular a line segment, is a convex function. This leads
to a natural way of extending IRIS algorithms to guarantee the
containment of line segments (and convex sets more generally)
provided they are collision-free. Given our focus on real-time
set generation, we specifically focus on adapting the IRIS-
ZO algorithm. The proposed modifications, however, can be
applied to both IRIS  and IRIS-NP2  as well.
A. Preliminaries
Let A Rn be a convex set, and
distA(x)  min
be the distance of a point x Rn to A. We verify in
Appendix A that the function distA(x) is convex in x. Given
that a line segment L  conv{v1, v2}, with v1, v2 Rn, is a
convex set by construction, it follows that the sub-level sets
BL(t)  {xdistL(x) t}
are convex [28, 3.1.6]. In Fig. 2, the level sets for five
different distances are indicated by the dashed lines. The
convexity of these sub-level sets implies that the tangent plane
a  (distL)c, b  aT c,
T  {xaT x b  0},
passing through any point c Rn, with distL(c)  t > 0,
is supporting to BL(t), and cannot intersect L. Note that the
gradient of the distance function to a line segment has a simple
closed-form solution. The gradient at c reads
(distL)c
c cproj2
where cproj is the projection of c onto L given by
if v1  v2,
otherwise.
Fig. 2: A single iteration of adding hyperplanes to the polytope in the EI-ZO algorithm. The configuration obstacles are shaded
in grey and the line segment seeding EI-ZO is shown in black. Starting from the left, first, a batch of configurations is sampled
in the current polytope given by the black rectangle. These samples are checked for collisions. The colliding configurations,
shown in red, are then used to seed a bisection search to find collisions that minimize the distance to the line segment. The
resulting candidates, indicated by the red stars (center frame), are ranked by their distance to the line segment in ascending
(cv1)T (v2v1)
in IV-B. Given a collision-free line segment L Cfree,
repeatedly search for points c that are in collision, and
place a hyperplane through point c according to (4) for each
found collision. By construction, these hyperplanes separate
each collision c from L. Therefore, if we repeat this for all
collisions in C, then the polytope constructed by intersecting
the halfspaces of each hyperplane that contains L is collision-
free and, crucially, contains L.
infinitely many hyperplanes and is therefore not practical in
the general case. In order to obtain a practical algorithm, we
construct our polytope P by iteratively placing hyperplanes
until P is sufficiently collision-free and meets the criterion
(1). First, we optimistically assume a large polytope P that
contains L is collision-free. We then proceed to search for
collisions inside of P. Every time we find a collision, we
place a separating hyperplane according to (4) that separates
the found collision from P, while still ensuring L P. Note
that placing a separating plane at a collision with a small
distance to L can simultaneously also separate collisions at
larger distances from L. As a result, optimizing the hyperplane
locations by attempting to find the collisions in P that
minimize the distance to L tends to produce polytopes with
substantially fewer hyperplanes. Therefore, a core subroutine
in EI-ZO is optimizing hyperplane locations by finding good
(although suboptimal) solutions to
minimize
distL(x),
subject to x Cfree, x P,
in order to reduce the number of hyperplanes that are required
for P to meet a termination condition that ensures (1).
boundary segments using a finite number of hyperplanes, we
use a small, finite step back > 0 from the found collisions
before placing the hyperplanes, similarly to .
procedure
constructs
probabilistically collision-free polytope that contains the
collision-free convex set (in this case a line segment) used
to seed the polytope construction. We accomplish this
by separating collisions from this seed set, by placing
hyperplanes tangent to the sub-level sets of the distance
function to the set. In the following section, we describe how
EI-ZO implements these ideas to inflate collision-free line
segments. It uses a zero-order optimization strategy on (8) to
search for close collisions and uses a probabilistic termination
condition (the unadaptive test in [22, 5.1]) that checks if
(1) is met and the polytope is sufficiently collision-free.
B. The EI-ZO Algorithm
Inflation
Zero-Order
algorithm
summarized in Alg. 1 and illustrated in Fig. 2.
Given a collision-free line segment in configuration space,
L  conv{v1, v2} Cfree, an initial polytope describing
the domain D  {xADx bD}1, such that L D, EI-
ZO computes a probabilistically collision-free polytope P that
contains L, and with probability larger than 1, is colliding
with no more than an -fraction of its volume. The algorithm
closely follows IRIS-ZO , and proceeds as follows.
We initialize P with the domain D. We then repeat
following
termination
criterion
unadaptive test is met. First, we uniformly sample a batch
of configurations S inside the current polytope P using hit-
and-run sampling . The batch size S is selected as
S  max{Np, M}, where M  2 log(1k)( 2)and Np
is the maximum number of samples to update. Here,  is the
admissible fraction of the volume allowed to be in collision,
(0, 1) is a decision threshold 2, and k is the admissible
uncertainty at the k-th iteration. The value of k is decayed
according to
2The parameter  serves as a decision threshold, that trades off the power
and cost of the unadaptive test. We typically choose   0.5.
Algorithm 1: EI-ZO
with L D, test parameters (, , ),
maximum step back max, and optimizer
parameters (Np, Nf, Nb).
with L P.
while TRUE do
S UNIFORMSAMPLE(P, M)
Scol POINTSINCOLLISION(S)
If UNADAPTIVETEST(SM
accept then break.
col PROJECTPOINTS(Scol, L)
col UPDATEPOINTSVIABISECTION(Scol, Sproj
ORDERANDPLACEHYPERPLANES(P, Sproj
return P
More details of this statistical test are given in [21, 5.1].
collecting the colliding configurations in the set Scol. We
terminate and accept P if SM
col M(1 ), where SM
denotes the number of collisions in the first M samples in S.
If the test fails, we modify P by adding more hyperplanes
in an attempt to reduce the fraction in collision. To this end,
we produce candidate solutions to (8) by performing gradient
descent on distL, with the first Np samples in Scol as feasible
initial guesses, while ensuring that the candidates remain in
collision.
L using the closed-form solution (6) in order to determine the
gradient direction given by (5). We then perform a bisection
search along the negative gradient direction, with a fixed
number of bisection steps, Nb, in order to find a point close
to the boundary of a configuration obstacle that is still in
collision. The resulting points S
col are our candidate local
solutions to (8). These steps correspond to the left and the
center frame in Fig. 2.
In a final step, we sort the candidates by their objective
value (8a), the distance to L, and place up to Nf hyperplanes.
This is done by iteratively intersecting the halfspace
ai  (distL)ci, bi  aT
Hi  {xaT
i x bi },
with P, where ci S
col is the closest remaining candidate,
and discarding any other candidates that now lie outside of
the updated polytope. The step back ensures that nonconvex
obstacles can be excluded from the polytope with only a finite
number of hyperplanes and needs to be computed for every
hyperplane separately. How to compute  is covered in IV-C.
Fig. 2 illustrates placing the hyperplanes in the rightmost
frame. In this frame, the collision with the largest distance is
walled off by the collision that is third-closest, and therefore
no separating plane needs to be constructed for this collision.
This entire procedure of sampling inside of the current
gradient directions, updating candidates through bisection
until the statistical test is passed.
C. Practical Algorithmic Considerations
In this section, we discuss three practical considerations:
setting a maximum number of iterations Nit, computing the
step back , choosing the number of bisection steps Nb.
Maximum Iterations If one is concerned with generating
regions quickly, it can be helpful to set a maximum number
of iterations of adding hyperplanes to P to upper-bound the
run time. This will void the probabilistic guarantee, but can
still be useful in combination with mechanisms for recovering
from collisions, as described in VI-B.
Computing the Step Back While there are methods that
can certify PWL paths or trajectories to be collision-free, e.g.
[3033], we check trajectories and paths for collisions by
finely discretizing them because it is more amenable to our
GPU-accelerated collision checker. In practice, this means that
the line segments of the PWL path may be very close to or
in collision. We handle these cases as follows.
If a candidate ci S
col has a distance that is smaller than a
user-specified collision tolerance tcol (i.e. if distL(ci) tcol),
then we throw an error stating that the line segment is likely in
collision and do not attempt to construct the region. In order
to fail fast it can also make sense to check the projection for
collisions at the start of the bisection search.
If a candidate ci S
col has a distance larger than the
collision tolerance tcol but smaller than the maximum step back
may exclude a part of L. In this case, we relax the step back so
L remains contained in the updated polytope. More precisely,
first we find the vertex that is closest or the strongest violator
to the new hyperplane and compute the corresponding value
i v1, aT
bi  max,
where ai and bi are computed using (10). If r > 0, then
the step back max excludes at least one of the vertices that
span the line segment. Therefore, we compute the step back
as follows
max r, if r > 0,
This forces the inclusion of L in P at the potential cost of
requiring more hyperplanes to meet the termination criterion.
Choosing the Number of Bisection Steps We use a
fixed number of bisection steps Nb in order to simplify the
parallelization of the algorithm. In order to choose Nb, we
suggest using the following rule of thumb:
where L is a guess for the maximum distance the bisection
search would have to move a collision in order to get to a
boundary of an obstacle. Note that choosing a small Nb does
not impact the correctness of the regions. Instead, it might
simply increase the runtime because more rounds of adding
hyperplanes are necessary.
D. CUDA Implementation of EI-ZO
Accompanying
library that implements EI-ZO using C and CUDA
software
configuration
decomposition
We implement EI-ZO directly on the GPU to minimize
costly data transfer between the CPU and the GPU. To this
and-run sampling , by assigning one CUDA thread per
random walk where each walk accepts after a fixed number
of mixing steps, forward kinematics by assigning one CUDA
thread per configuration, collision checking by assigning
one CUDA thread per collision pair, and the projection
as well as the bisection updates by assigning one CUDA
thread per configuration. To sort and place the non-redundant
As a result, at run time, we only need to send the seed line
segment to the GPU and transfer the final polytope back from
the GPU. Crucially, the samples never leave the GPU memory.
collision geometries, but could readily be extended to support
more geometries.
V. GENERATING COLLISION-FREE POLYGONAL PATHS
USING DYNAMIC ROADMAPS
Our motion planning pipeline requires finding at least one
collision-free PWL path in order to construct a sequence of
convex sets that connects the starting configuration to the goal
via EI-ZO. To this end, we employ dynamic roadmaps (DRMs)
which are designed to rapidly find these paths in changing
environments.
DRMs  approximate Cfree with a probabilistic roadmap
(PRM) , discretize the robot workspace into voxels, and
build large lookup tables that map activated voxels to nodes
and edges of the PRM that are in collision. For reference, see
Fig. 3. The key idea is that approximating the current perceived
environment by activating voxels, and subsequently pruning
the PRM with lookup tables, is faster and leads to better
motion plans than running a single-query motion planner .
burden of motion planning (e.g. collision checks) to the offline
construction of the roadmap, and thus enable fast planning in
changing environments.
Fig. 3: A DRM is a PRM with additional lookup tables
that allow the PRM to rapidly be updated provided task
space observations of obstacles. To this end, the task space is
discretized into voxels. We associate a circumscribing sphere
with each voxel as collision geometry for collision checking.
A portion of these spheres are shown in purple in the right
figure. Next, a lookup table is constructed, Mc, that maps
each of these spheres to nodes in the road map that would
collide with the sphere. Above, a single sphere is shown in
yellow on the right, along with three configurations, shown
in red, green, and blue, that collide with it and are stored
in Mc. On the left, a cartoon of the configuration space is
shown with the underlying PRM and configuration obstacles.
The three colliding configurations are highlighted again in red,
the yellow sphere is highlighted in yellow.
We closely follow the implementation in , which
shows that GPU-accelerated collision checking both enables
the construction of large-scale DRMs and effective online
planning for a mobile bimanual manipulator. Similarly, we
skip constructing the edge collision map, and use lazy collision
checking online to invalidate colliding edges [39, 40].
A. Offline Roadmap Construction
Before any online planning, we construct our DRMs offline
using a similar procedure . Our DRMs consist of 4 data
A node map Mn : I C that maps a node identification
number (node id) i I to its configuration,
a node adjacency map Ma : I P(I), where P
denotes the power set of I, which maps a node id to
all its neighbors,
a collision map Mc : J P(I) that maps a voxel
identification number (voxel id) j J to all node ids
that are in collision if the voxel j is active,
a pose map Mp : I SE(3) that maps each node id to
its corresponding end-effector pose.
Fig. 3 depicts a high-level visual description of the roadmap
and collision map. We do not detail the construction procedure
B. Online Planning given Perception
Once we have our DRM formed by these four data
paths online given perception. Online, we assume we are
given a voxel map representation of the world, a starting
configuration and a goal pose Pg SE(3). The planning then
proceeds in three phases.
1) Build the collision set CS P(I) that contains the
ids of all nodes that are colliding with the voxel map.
Given a point cloud, this is done by activating all voxels
containing points and subsequently using the collision
map Mc to find all nodes in collision.
2) Determine a goal configuration g given our goal pose
Pg by solving an inverse kinematics (IK) problem. We
use the pose map Mp and the collision set to find
collision-free configurations that lie near Pg. The closest
configurations are used to warmstart a small IK problem
to reach the final goal pose.
3) Connect the start s and goal g configurations up to the
checking and greedy short cutting to find the collision-
free PWL path.
The right side of Figure 3 depicts the collision map being
used to quickly prune out nodes in collision, and the left side
of Figure 3 shows the resulting collision-free roadmap that
can be efficiently used for path planning. We compute the
obstacle representations for collision checking by voxelizing
a point cloud observation of the environment and representing
the collision geometries of the voxels as spheres.
VI. THE MOTION PLANNING PIPELINE
Our motion planning pipeline takes a goal end-effector
perceived obstacles as input, and produces a collision-free
trajectory as output. First, the DRM is leveraged to find a target
configuration by solving an IK problem, and subsequently to
find a collision-free PWL path. The details on how this is
done are covered in V. Next, the path is inflated using EI-ZO
(VI-A). In a last step, we optimize our motion plan by using
DBMPs and check the result for collisions using fine-grained
sampling along the trajectory. If collisions are present, we use
the found collisions to refine the convex sets and re-solve the
DBMP trajectory optimization until no collisions are found
in the path (VI-B). We illustrate the entire motion planning
pipeline in Fig. 4.
(VI-C). Certain DBMPs are not restricted to sequences of
convex sets and can handle more general covers of Cfree,
e.g. [10, 11, 1618]. Therefore, it can be beneficial to inflate
multiple PWL paths in the hope that the safe sets intersect
in ways that reveal new paths around obstacles that are not
captured by the DRM.
A. Inflating a Single Path
Given a collision-free PWL path with K segments, v0kK
such that Lk : conv{vk, vk1} Cfree for k  0, . . . , K
inflate the path in sequence. Starting at the first line segment
with k  0, we construct the probabilistically collision-
free polytope Pk, which is guaranteed to contain Lk, and
subsequently check if Lk1 is already contained in one of the
previously generated polytopes. We only inflate Lk1 if it is
not yet contained and increment k. This is repeated iteratively
until k  K 1.
B. Rapidly Recovering from Detected Collisions
The computed regions are only probabilistically collision-
free. This means at planning time, it is possible that the
optimized trajectory contains collisions. Given that the PWL
path used to generate the polytopes is assumed collision-free,
we have a natural way of iteratively refining the sets until
the trajectory is collision-free. Given a trajectory, we rapidly
check it for collisions by finely discretizing it. If collisions
are found, we treat them as candidate points to warm start
our search in (8) to modify the corresponding sets. We then
re-solve the trajectory optimization and repeat the procedure
until the trajectory is collision-free.
In detail, the procedure is the following. For each set, we
aggregate all the found collisions inside of the set in Scol. Next,
we repeat the last three steps of Alg. 1 in order to exclude these
collisions by updating the set. After the found collisions have
been excluded, we still need to verify that the new regions still
include the entire PWL path. While the line segments that seed
the sets remain in the sets by construction, our path inflation
approach in VI-A may have attempted to cover additional line
segments with a single set for efficiency. There is no guarantee
that these other line segments remain contained in the edited
set as well. Therefore, we check that each segment of the
If not, we inflate the corresponding segment. This procedure
is summarized by the flowchart in Fig. 5 and is repeated until
the found path is collision-free.
C. Inflating Multiple Paths
Some DBMPs can handle graphs of safe sets rather than
just sequences [10, 11, 1618]. If we inflate more than just
the sequence of safe sets associated with the shortest path in
the DRM, these approaches can potentially recover higher-
quality trajectories. In particular, the convex sets associated
with a longer, suboptimal path in the DRM could yield a better
optimized trajectory. In an attempt to capture these benefits, we
propose a method to inflate additional distinct paths through
the DRM, besides the shortest, in order to add more safe sets.
Our heuristic for adding additional paths assumes there
exists at least one safe set from a previous path that contains
neither the start nor the goal. The heuristic is to select a
random convex set that has not yet been selected, add all
nodes of the DRM that lie inside of the selected polytope
to the collision set CS (see V-B), rerun Aon the DRM,
and inflate the resulting path according to VI-A. If at any
point the procedure fails, we simply terminate.
The idea behind this heuristic is to use the previously
created sets to push the PWL path outside of the currently
inflated one.
Fig. 4: This figure depicts our motion planning pipeline. Our motion planning pipeline is split into an offline phase in which
a DRM is constructed, and an online phase where we use the DRM to generate a collision-free PWL paath, inflate the path,
and use a DBMP to optimize a trajectory. Starting from the left, in the first figure the DRM is constructed. In the second, we
observe a new obstacle (red blob), and build the collision set (red dot). Using the updated DRM, we then solve the IK problem
for the goal (yellow star), and find a collision-free path connecting the start (blue dot) to the goal. We inflate this path to an
SCS using EI-ZO in the third figure. In the fourth figure, we solve the motion planning problem using DBMPs and check the
trajectory for collisions, finding one inside of the green set, indicated by the red arrow. In the fifth figure, we use the recovery
mechanism from VI-B to modify the green set and produce a collision-free path. In general, these last two steps need to be
repeated multiple times.
trajectory
optimization
collision-
contained?
Fig. 5: Flowchart for recovering from collisions found in the
optimized trajectory.
VII. EXPERIMENTAL EVALUATION
In this section, we evaluate our proposed motion planning
pipeline experimentally. This section is split into two parts.
In the first part, VII-A we discuss our simulation benchmark
along with the baseline approach we compare against. In the
second part, VII-B, we validate our approach on our hardware
A. Simulation Benchmark
This section covers the simulation benchmark, which
consists of two environments used to generate randomized
motion planning problems in two and seven dimensions.
For each environment, we solve two types of problems:
(1) minimum distance problems, where we seek to find
the shortest collision-free PWL path, and (2) minimum
time problems, in which we seek a smooth, velocity- and
acceleration-constrained curve that minimizes the time needed
to traverse between the start and goal.
1) Environments:
benchmark
environments
depicted in Fig. 6. In the Forest environment, 15 circular
obstacles are scattered randomly in the center portion of a
square-shaped domain with a side length of 10. The center
portion corresponds to a square with a side length of 7, and
the obstacles have a radius of 0.35. In this environment,
shown on the left in Fig. 6, the goal is to find a collision-free
path from the bottom left to the top right of the environment.
Fig. 6: Our simulation benchmark consists of the Forest
shown on the right. A collision-free motion plan starting at
the red shaded robot and ending at the blue is shown in the
Franka environment.
In the Franka environment, 20 spherical obstacles are
randomly scattered in front of a seven degree-of-freedom
Franka Research 3 (FR3) robot manipulator. The collision
geometry of the FR3 is approximated with 33 spheres, and
the table is modeled as a box. As a result, 1187 collision pairs
need to be checked, of which 527 are associated with self-
collisions. In this environment, the robot always starts at a
random configuration on the right side of the table and needs
to plan to a random pose on the left side of the table. The
Franka environment is shown on the right in Fig. 6.
2) Problem Types: For each environment, we consider
two problem types: minimum distance and minimum time
problems. For the minimum distance problem, we seek the
shortest collision-free PWL path p, with length L(p), that
connects the start s to the goal g configuration,
minimize
subject to p Cfree,
pinit  s, pterm  g,
where pinit denotes the start, and pterm the end of p.
parametrized curve p, that obeys velocity and acceleration
amount of time T, while starting and stopping at a standstill.
The problem reads:
minimize
subject to p Cfree,
vmin p(t) vmax t [0, T],
amin p(t) amax t [0, T],
where vmin, and vmax denote the minimum and maximum
maximum acceleration.
3) Baseline
nonlinear
trajectory
optimization (NTO), which we warm start from the path found
by the DRM, as our baseline approach. To this end, we employ
the KinematicTrajectoryOptimization class in Drake [42, link]
to transcribe the NTO problems and solve them with SNOPT
or IPOPT [43, 44]. For both problem types, (14) and (15), we
discretize the trajectory and enforce the collision-avoidance
constraint point-wise via [42, link] at Nc points.
For the minimum distance problems, we warm-start the
search with the PWL path found by the DRM. For the
minimum time problems, we warm-start the search by setting
the control points of a 4th order B-Spline to the nodes of the
PWL path from the DRM.
4) Employed DBMPs: For the minimum distance problem,
given an SCS, the problem is convex and has a straightforward
transcription as a second-order cone program, see Appendix
C. We solve these problems directly using MOSEK
and call the approach LSCS standing for PWL shortest path
through an SCS. In the second approach, we inflate two paths
using VI-C, and solve the mixed-integer convex program
formulation of the Euclidean distance shortest path problem
on a graph of convex sets problem [46, Eqn. 5.5] using Gurobi
. We abbreviate this approach as LGCS standing for PWL
shortest path through a graph of convex sets.
We choose these two approaches for the minimum distance
problem to evaluate the speed and reliability of the simple
LSCS approach, and explore the value that is added by
inflating multiple paths, by using the more expensive LGCS.
For the minimum time problem, we use the recently
developed SCSTrajopt , which supports the minimum time
objective and rapidly finds smooth, velocity-, and acceleration-
constrained trajectories using alternations between two convex
optimizations. We solve these problems with Clarabel ,
and abbreviate this approach as SCSTO.
5) Results: The simulation experiments are run on an Intel
i9-10850K CPU and a NVIDIA GeForce RTX 3090 using the
560.28.03 graphics driver and CUDA 12.6.
We solve each motion planning problem for 10 random
seeds of the environment, 10 random seeds for the DRM
planning problems for each trajectory optimization approach.
The DRM sizes for the Forest environment are 200, 400, 800,
and 1600, and for the Franka environment, the sizes are 3000,
for both environments and problem types. Please refer to
Appendix D for more specifics on the used parameters. The
benchmark results are summarized in Tab. I.
approaches
substantial speedup and boost in the reliability over NTO. We
find that, provided DRM success, the SCS approaches never
and 15.7 times faster in the franka environment, on average.
Given DRM success, NTO produced a collision-free trajectory
in 71.5 of the instances in the Forest environment and 72.8
of the instances in the Franka environment. We found tuning
NTO for the minimum time problem instances in the Forest
environment particularly challenging, only achieving a success
rate of 45.9.
Provided NTO succeeded, it produced equivalent cost
trajectories on the Forest minimum distance. On the minimum
time instances, it improved on the cost by 7.7, provided the
optimizer found a solution. For the Franka minimum distance
and minimum time instances, it reduced the cost to the SCS
approaches by 33.7, and 28, respectively.
Inflating two paths and solving the minimum distance
problem using LGCS only yielded marginal improvements in
the cost of the trajectory, while dramatically increasing the
computation time.
For the Forest environment, the recovery mechanism
described in VI-B, was triggered in 5.6 of the minimum
distance and 0.46 minimum time problems. In the Franka
minimum distance and minimum time instances, respectively.
In summary, our pipeline affords a slight increase in
trajectory cost, at the benefit of substantially increasing
reliability and reducing computation times.
B. Validation on Hardware
In this section, we validate our pipeline on our system
that consists of a KUKA LBR iiwa 7 R800 and three Intel
RealSense D415 depth cameras for perceiving changes to the
table-top environment shown in Fig. 1 and Fig. 7. For this
SCSTrajopt  with Clarabel  to find good solutions to
(15). We constrain the velocity between -1 and 1 [ rad
the acceleration between -1 and 1 [ rad
s2 ] for all joints.
In our hardware experiments, we alternate between pose
targets on the right and the left of the table. Between
placing or moving obstacles in the center of the table for
the robot manipulator to plan around. We approximate the
robot collision geometries with 11 boxes, resulting in 105
self-collision pairs. For our hardware experiments, we use an
Minimum Distance
Minimum Time
Environment
DRM num. LS
DRM path len.
TO Approach
cost (S only)
time total [ms]
time TO [ms]
time CS [ms]
CFR given TO S
abbreviation
expanded
success rate
collision-free rate
trajectory optimization
line segments
convex sets
TABLE I: Simulation results of solving the minimum distance and minimum time problems on both the Forest and Franka
environments. The table indicates the averages and empirical standard deviations of the statistics across the different road map
Fig. 7: In our hardware experiments, we alternate between planning to the right and the left side of the table. Between plans
we place, move and remove obstacles. Starting from the left, first we place the shoe rack and box, highlighted in green, then
we run our planner and move the robot to the right side of the table. Next, we slide the shoe rack closer to the robot and run
our planner again. The shoe rack forces the arm to move in a higher arc to reach the left side of the table.
Intel i9-7900X CPU, a Nvidia GeForce 2080Ti GPU using the
555.42.06 driver and CUDA 12.5.
We implement a simple perception pipeline that uses the
Python interface to the depth cameras and down-samples the
point clouds to voxels with a side length of 8 cm. We associate
a sphere collision geometry that circumscribes each voxel as
shown in the center frame o
