=== PDF文件: Global Contact-Rich Planning with Sparsity-Rich Semidefinite Relaxations.pdf ===
=== 时间: 2025-07-22 16:09:44.243799 ===

请你只输出如下JSON，所有字段都必须有，且每个“关键词”字段只允许输出一个最核心的最有代表性的中文关键词，要中文关键词，如果是英文关键词就尝试翻译成中文（不能是英文，不能是多个，不能有逗号、分号、空格），否则视为不合格。不要输出任何解释或正文，只输出JSON。
{
  "论文标题": "",
  "研究主题关键词": "",
  "应用场景关键词": "",
  "主要方法关键词": "",
  "创新点关键词": "",
  "主要结论关键词": ""
}
内容：Global Contact-Rich Planning with
Sparsity-Rich Semidefinite Relaxations
Shucheng Kang1, Guorui Liu2, Heng Yang1
1School of Engineering and Applied Sciences, Harvard University
2School of Mathematical Sciences, University of Science and Technology of China
Equal contribution
Markov Sparsity
(Planning Horizon)
Specific Sparsity
Fig. 1: Contact-rich planning is sparsity-rich. (a) Sparsity graph of planar hand manipulation showing two types of sparsity. (b)
Sparsity enables high-order and tight, yet small-scale, semidefinite programming (SDP) relaxations solvable by off-the-shelf
SDP solvers, computing certified near globally optimal trajectories for a suite of simulated problems. (c) Real-world validation
on push-T. Planning powered by global optimization succeeds the task even under severe model mismatches and disturbances
(from top to bottom: clean T; T tied up by a cable; T on top of a cluttered table; and T inside a sliding box).
AbstractWe show that contact-rich motion planning is also
sparsity-rich when viewed as polynomial optimization (POP). We
can exploit not only the correlative and term sparsity patterns
that are general to all POPs, but also specialized sparsity patterns
from the robot kinematic structure and the separability of contact
modes. Such sparsity enables the design of high-order but sparse
semidefinite programming (SDPs) relaxationsbuilding upon
Lasserres moment and sums of squares hierarchythat (i) can
be solved in seconds by off-the-shelf SDP solvers, and (ii) compute
near globally optimal solutions to the nonconvex contact-rich
planning problems with small certified suboptimality. Through
extensive experiments both in simulation (Push Bot, Push Box,
Push Box with Obstacles, and Planar Hand) and real world
(Push T), we demonstrate the power of using convex SDP
relaxations to generate global contact-rich motion plans. As
a contribution of independent interest, we release the Sparse
Polynomial Optimization Toolbox (SPOT)implemented in C
with interfaces to both Python and Matlabthat automates
sparsity exploitation for robotics and beyond.
I. INTRODUCTION
Contact-rich planning plays a fundamental role in robotics
tasks ranging from manipulation to locomotion [29, 9, 14].
At the heart of such planning problems lie two interrelated
and where to establish or break contact is critical, yet the
number of possible contact sequences grows exponentially
with the number of contact modes and the planning horizon;
(b) Nonlinear dynamics and nonconvex geometric constraints:
the planned trajectory must satisfy the systems nonlinear
dynamics and geometric constraints such as avoiding self and
obstacle collisions. Together, these challenges exacerbate the
problems nonconvexity and computational complexity.
Problem statement. Let N represent the planning hori-
zon with [N] : {1, 2, . . . , N}. Define the state trajectory
k0 Rnx and the control input trajectory {uk}N1
Rnu. For contact-rich planning problems, we introduce con-
tact variables {k}N1
either as a set of binary contact modes or as continuous contact
forces (see examples in IV). With these definitions, we focus
on the following general contact-rich planning problem
k(xk, uk, k)
subject to
x0  xinit
Fk(xk1, uk1, k1, xk)  0, k [N] (1c)
(uk1, k1, xk) Ck, k [N]
where k, k  0, . . . , N represents instantaneous loss and
terminal loss functions. Fk represents the discretized system
dynamics obtained from differential algebraic equations and
multiple shooting, possibly involving explicit or implicit con-
tact mode switching. Ck imposes various types of constraints
on uk1, k1, xk, including (a) control limits; (b) geometric
constraints such as collision avoidance; (c) complementarity
constraints related to contact. A well-known special case
of (1) occurs when the dynamics are linear when fixing
ks. In such case, (1) can be modeled either as mixed-
integer linearquadratic programming [10, 28] or as linear
complementarity problems [3, 51].
In this paper, we do not assume linearity or convexity but
assume (a) k and Fk are polynomial functions; (b) Ck is ba-
sic semi-algebraic (i.e., described by polynomial constraints).
Formulating robotics problems as polynomial optimization is
now well established in the literature [23, 47, 16, 39], because
3D rotations and rigid body dynamics expressed in maximal
coordinates  admit natural polynomial representations.
Previous methods. We briefly review five different methods
for solving the contact-rich planning (1). (a) Hybrid MPC:
These methods alternate between contact sequence generation
using discrete search [7, 45, 8, 30] and continuous-state
planning with a fixed sequence. (b) Mixed-integer program-
to mixed-integer convex programming (with linear dynam-
ics) [10, 28] or mixed-integer nonconvex programming (with
nonlinear dynamics) . These methods scale poorly with the
planning horizon, as the worst-case computational complexity
grows exponentially with the number of binary variables. (c)
Dynamics smoothing: This approach approximates nonsmooth
complementarity constraints with smooth surrogate functions,
simplifying the problem into a smooth nonlinear programming
formulation suitable for local solvers [6, 38, 31, 37]. Convex
smoothing methods  also exist, at the cost of locally
linearizing the dynamics. (d) Contact-implicit methods: These
mainstream methods encode contact modes implicitly through
contact forces and complementarity constraints. Numerous
local solvers are based on this framework [2, 52, 35, 27,
planning problems fail the common constraint qualifications
that are crucial for the convergence of numerical solvers. (e)
Graph of convex sets (GCS): As a recently proposed powerful
planning framework that explicitly models both discrete and
continuous actions, GCS has been extended to contact-rich
tasks [13, 48, 32]. These methods can be viewed as an
extension of mixed-integer nonconvex optimization with two-
level convex relaxations where level one is a semidefinite
relaxation and level two involves inequality multiplication.
relaxations and fast solve times remains challenging, and the
current GCS framework has yet to fully integrate nonlinear
dynamics with geometric constraints.
Is it possible to solve the contact-rich planning
problem (1) to (near) global optimality efficiently?
Sparse Moment-SOS hierarchy. Modeling contact-
implicit planning as polynomial optimization (POP) in (1)
brings both opportunities and challenges.
Opportunities. Lasserres hierarchy of moment and
sums-of-squares (SOS) relaxations  provides a prin-
cipled and powerful machinery for global optimization
of POPs through convex relaxations. Particularly, the
Moment-SOS hierarchy generates a series of convex
semidefinite programs (SDPs) with growing sizes whose
optimal values provide nondecreasing lower bounds that
asymptotically converge to the global minimum of (1).
Combined with a feasible (or locally optimal) solution
of (1) that provides an upper bound to the global
(sub)optimality certificates by measuring the relative gap
between the lower bound and the upper bound. To en-
hance scalability of the hierarchy, sparse Moment-SOS
hierarchy has been proposed to exploit sparsity in the
sparsity [43, 26] (see more details in II). Notably, the
Julia package TSSOS  supports automatic sparsity
exploitation as long as the user provides a POP formu-
lation. The recent work  in robotics applied TSSOS
to several motion planning problems and demonstrated
that sparse relaxations can deliver small suboptimality
gaps. Furthermore,  has shown that all trajectory opti-
mization problems exhibit a generic chain-like correlative
sparsity pattern and designed a GPU-based ADMM SDP
solver that achieves significant speedup than off-the-shelf
SDP solvers. Can we directly apply sparse Moment-SOS
relaxations to the contact-implicit planning problem (1)?
Challenges. The answer is unfortunately NO, due to three
challenges. First, multiple contact modes will make the
chain-like correlative sparsity pattern introduced in
too large to be solved efficiently. Second, TSSOS allows
exploiting more flexible sparsity patterns but its automatic
sparsity exploitation operates like a black boxit does
not visualize the sparsity patterns being exploited and it is
unclear whether robotics-specific domain knowledge can
lead to customized sparsity. Third, as reported in , the
suboptimality gaps when using TSSOS for many smooth
planning problems are already large (above 20), not to
mention the extra nonsmoothness and combinatorial com-
plexity brought by contact-implicit planning. As shown
certain difficult instances of (1).
Contributions. In this paper, we tackle the aforementioned
challenges and show that it is indeed possible to solve many
instances of the contact-implicit planning problem (1) to near
global optimality. The key strategy is to build sparsity-rich
semidefinite relaxations from the ground up, for robotics.
We summarize our contributions as follows.
(I) White-box sparsity exploitation. We provide a tutorial-
style review of the fundamental mathematical concepts
underpinning correlative and term sparsity for POPs,
and further ground our discussion in a concrete contact-
implicit planning problem. We build a new C Sparse
Polynomial Optimization Toolbox (SPOT), interfacing
both Matlab and Python, that (a) is faster than TSSOS,
(b) offers richer relaxation options, and (c) visualizes the
automatically discovered sparsity patterns (see Fig. 1).
(II) Robotics-specific sparsity. Beyond automatic exploita-
tion of the generic correlative and term sparsity, we show
that it is possible and crucial to exploit robotics-specific
sparsity patterns. Particularly, we investigate sparsities de-
rived from robot kinematic chains and separable contact
patterns achieve both tighter lower bounds and reduced
computation times compared to automatically generated
ones in large-scale problems such as Planar Hand.
(III) Robust minimizer extraction. An important but often
overlooked problem in SDP relaxations is how to extract
good solutions to the nonconvex optimization from op-
timal SDP solutions, especially when the relaxation is
not tight (i.e., the suboptimality gap is large). Inspired
by the recent advances in Gelfand-Naimark-Segal (GNS)
routine for sparse Moment-SOS relaxations that demon-
strates superior robustness over naive extraction methods
previously implemented in [16, 25].
(IV) Extensive case studies. We test our sparse semidefinite
relaxations on five contact-rich planning problems: Push
Planar Hand. Of independent interests, some of our poly-
nomial modeling techniques also appear to be new in the
planning literature. Thanks to rich sparsity, the generated
small-to-medium scale SDP relaxations can be solved in
seconds while achieving decent tightness and certified
global optimality. Furthermore, we showcase robust push-
T performance of our SDP relaxations using a real-world
robotic manipulator. In fact, with global optimization,
model predictive control is so robust that it succeeds
the task even under severe environment disturbances that
effectively make the model wrong (see Fig. 1).
Paper organization. We present correlative and term spar-
sity in II, robotics-specific sparsity in III. We give numerical
and real-world experiments in IV, and conclude in V.
Notations. Let x  (x1, . . . , xn) be a tuple of variables and
R[x]  R[x1, . . . , xn] be the set of polynomials in x with real
coefficients. A monomial is defined as x  x1
A polynomial in x can be written as f(x)  P
with coefficients f R. We denote the set of all polynomials
with degree less than or equal to d as Rd[x]. The support
of f is defined by supp(f)  { Nn  f  0}, i.e., the
set of exponents with nonzero coefficients. The set of all
variables contained in f is defined by var(f). Let xNn
the standard monomial basis, abbreviated as [x]d. Given an
index set I [n], let x(I)  (xi, i I) and [x(I)]d
denote the standard monomial basis of the subspace spanned
by the variables xi, i I. An undirected graph G(V, E)
consists of a vertex set V  v1, v2, . . . , vn and an edge set
E {(vi, vj)  vi, vj V, vi  vj}. Let Sn denote the space
of nn symmetric matrices, and Sn
denote the cone of nn
symmetric positive semidefinite (PSD) matrices.
II. CORRELATIVE AND TERM SPARSITY
In this section, we review a systematic mechanism to relax a
general (nonconvex) polynomial optimization problem (POP)
as a (convex) semidefinite program (SDP) while exploiting two
levels of sparsity: (a) variable levelcorrelative sparsity (CS);
and (b) term levelterm sparsity (TS). Formally, we consider
the following POP
g1(x) 0, . . . , gmineq(x) 0,
where the objective function f and the constraints gi, hi are
all real polynomials. To ground our discussion in a concrete
robotics example, let us consider the following simple contact-
rich motion planning problem.
Example 1 (Double Integrator with Soft Wall). As shown in
Fig. 2, consider a point mass m driven by a control force u
that can bounce between two soft walls with spring coefficients
k1 and k2. Denote the system state as (x, v) (x: position, v:
velocity), the control input as u, and the two walls forces
as (1, 2), we consider the following trajectory optimization
(optimal control) problem
xk1 xk  t  vk
vk1 vk  t
m  (uk  1,k 2,k)
d1  xk 0
x0  xinit
v0  vinit
where t represents the time discretization, (3a) formulates
a quadratic regulation loss function around x  0, v  0,
(3b)-(3c) represent system dynamics, (3d) enforces control sat-
between position and contact forces, and (3g) provides the
initial condition. 1,k denotes the contact force at step k.
Outline. We begin by introducing the fundamentals of
chordal graphs, a key mathematical tool for analyzing sparsity
patterns (II-A). Next, we review correlative sparsity (CS)
(II-B) and term sparsity (TS) (II-C) separately. Finally,
we introduce our high-performance C sparse polynomial
optimization toolbox, SPOT (II-D).
Fig. 2: Double integrator with soft wall.
A. Chordal Graph
Definition 2 (Chordal graph). A graph G  (V, E) is chordal
if every cycle of four or more vertices has a chordan edge
connecting two non-adjacent vertices in the cycle.
For a quick example, the graph in Fig. 3(a) is not chordal
but the graph in Fig. 3(b) is. Apparently, one can change a
non-chordal graph to chordal by adding edges. This is the
notion of a chordal extension.
Chordal extension. A graph G(V , E) is called a chordal
extension of graph G(V, E) if (a) G is chordal, and (b)
E. The ideal objective of chordal
extension is to add the minimum number of edges to G to
make G chordal. However, it is known that finding such a
minimal chordal extension is NP-complete . A common
heuristic for approximating the minimal chordal extension is
the minimal degree (MD) chordal extension . An alter-
native heuristic is to select vertices based on the number of
additional edges (MF) required to maintain chordality . We
summarize the MD chordal extension method in Algorithm 1
and MF chordal extension in Algorithm 2 in Appendix A. In
our SPOT package, we implement both algorithms.
Maximal cliques. Once the chordal extension is con-
Definition 3 (Clique). A clique in a graph G(V, E) is a subset
of vertices C V where every pair of vertices is connected
by an edge. A clique is maximal if it is not properly contained
within any other clique in G.
The nice consequence of the chordal extension is that
the maximal cliques of a chordal graph can be enumerated
efficiently in linear time in terms of the number of nodes and
edges [11, 4, 12]. Identifying all maximal cliques in a chordal
graph plays a fundamental role in exploiting sparsity patterns.
Fig. 3: An example of chordal extension and maximal cliques.
Example 4 (Chordal Extension and Maximal Cliques). Con-
sider the graph in Fig. 3(a) that is non-chordal. The MD
chordal extension Algorithm 1 adds two edges (B, D), (B, F),
leading to the chordal graph in Fig. 3(b). The maximal cliques
of the resulting chordal graph are {A, B, D}, {B, D, E},
{B, E, F}, and {B, C, F}, as shown in Fig. 3(c).
With the notion of a chordal graph and maximal cliques, it
is natural to use such a graph-theoretic tool to exploit sparsity.
B. Correlative Sparsity
As mentioned before, correlative sparsity (CS) seeks to
exploit sparsity in the variable level. Roughly speaking,
the intuition is that we can construct a graph that represents
the connectivity in the POP (2), perform a chordal extension
to that graph, and find its maximal cliques to group the
(potentially very large number of) POP variables into many
groups where each group only contains a few variables .
CS graph construction. The graph Gcsp(V, E) is the cor-
relative sparsity pattern (CSP) graph of a POP with variables
x Rn if V  [n] and (i, j) E if at least one of the
following three conditions holds:
1)  supp(f), s.t. i, j > 0,
2) k [mineq], s.t. xi, xj var(gk),
3) k [meq], s.t. xi, xj var(hk).
In words, the nodes of the CSP graph represent variables
of the POP, and a pair of nodes are connected if and only if
they simultaneously appear in the objective or the constraints.
Chordal extension and grouping. With the MD chordal
extension Algorithm 1 (or the MF chordal extension Algo-
rithm 2), we compute the chordal extension of Gcsp denoted
(Gcsp)and its maximal cliques {Il}p
Il contains a set of nodes (variables). We then partition the
constraint polynomials g1, . . . , gmineq and h1, . . . , hmeq into
groups {gj  j Gl} and {hj  j Hl}, where Gl and Hl,
l [p] index the inequality and equality constraints involving
the variables in Il, respectively. Formally, this is
1) j Gl, var(gj) Il,
2) j Hl, var(hj) Il.
We make this concrete by recalling our robotics Example 1.
Example 5 (CSP Graph of Example 1). Fig. 4 shows the
CSP graph of Example 1. It is already a chordal graph with-
out chordal extension. Two maximal cliques are highlighted:
{x0, v0, 1,0, 2,0} and {x0, x1, v0}. There is an edge between
x0 and v0 since x1 x0  t  v0 shows up in (3b).
After grouping the variables into cliques {Il}p
l1 and the
polynomial constraints into subsets Hl, Gl, we can design
Fig. 4: CSP graph of the toy Example 1. Red circle: maxi-
mal clique {x0, v0, 1,0, 2,0}. Orange circle: maximal clique
{x0, x1, v0}. Only variables in the first and last planning steps
are shown for simplicity.
a hierarchy of sparse moment and sums-of-squares (SOS)
relaxations to globally optimize the POP (2).
Before we present the sparse Moment-SOS hierarchy, it is
useful to understand the dense Moment-SOS hierarchy.
Dense Moment-SOS relaxations. Recall the POP (2). Let
y  (y) be a sequence of real numbers indexed by the
standard monomial basis of R[x]. Define the Riesz linear
functional Ly: R[x] R as:
f(x) R[x]
In words, the Riesz linear functional Ly transforms a real
polynomial f to a real number that is the inner product
between y and the vector of coefficients of f. The notation
of Ly can be naturally extended to polynomial vectors and
Functional).
. Applying Ly, we have
Ly([x]1 [x]T
where the number y1,0,0 is applying Ly to the monomial x1
With the Riesz linear functional, we can state the dense
Moment-SOS hierarchy. Essentially, through the Riesz linear
functional Ly, the Moment-SOS hierarchy relaxes the original
POP (2) as a convex optimization problem whose variable
becomes the sequence y. The reason why this is called a
hierarchy is because one can make the sequence arbitrarily
Proposition 7 (Dense Moment-SOS Hierarchy). Consider
the POP (2). Let dg
deg(gj)2, j [mineq] and
j  deg(hj), j [meq]. Define
deg(f)2,
j[mineq] ,
Given a positive integer d dmin, the d-th order dense
Moment-SOS hierarchy reads:
gj  [x]ddg
hj  [x]2ddh
The optimal value of the convex optimization (8) converges to
the optimal value of the nonconvex POP (2) as d .
In (8), the matrix Ly([x]d[x]T
d) is usually called a moment
matrix and it is enforced by a positive semidefinite (PSD)
constraint. One can see that the dense Moment-SOS hierarchy
can become expensive very quickly as the relaxation order d
increases. This is because the dense moment matrix at order
d has size (nd
d ) which quickly makes the PSD constraint too
large to be handled by off-the-shelf SDP solvers (recall that the
length of the monomial basis indexing the moment matrix
[x]dis (nd
Moment-SOS relaxations with CS. On the other hand,
with correlative sparsity and when the variables are divided
into cliques {Il}p
l1 where the size of clique Il is nl, then
instead of generating a single moment matrix with size (nd
the sparse Moment-SOS hierarchy will generate p moment
matrices where the size of each moment matrix is (nld
different way to view this is that, correlative sparsity breaks a
large PSD constraint into multiple smaller PSD constraints.
Let us formalize this.
Proposition 8 (Sparse Moment-SOS Hierarchy). Consider the
POP (2) and assume its variables are grouped into cliques
l1 and its constraints are grouped into Gl, Hl where Gl
and Hl include constraints only involving variables x[Il]. For
any fixed integer d dmin (dmin defined as in (7)), define
the following polynomial matrices and vectors associated with
each clique Il as:
Md(Il)  [x(Il)]d [x(Il)]T
Md(gj, Il)  gj  [x(Il)]ddg
j [x(Il)]T
Hd(hj, Il)  hj  [x(Il)]2ddh
Let g0 : 1, then Md(g0, Il)  Md(Il). The d-th order
Moment-SOS hierarchy with correlative sparsity reads:
Ly (Md(gj, Il)) 0, j {0} Gl, l [p] (10b)
Ly (Hd(hj, Il))  0, j Hl, l [p]
the sequence d as d .
Dense Moment Relaxation
Sparse Moment Relaxation
Fig. 5: Comparison of the moment matrices in dense and
sparse Moment-SOS relaxations.
As an illustrative example, suppose the POP has two vari-
ables x  (x1, x2). Then the moment matrix corresponding
to the dense Moment-SOS hierarchy at d  2 is shown in
Fig. 5 left, where its rows and columns are indexed by the
standard monomial basis [x]2. However, suppose from the
chordal extension of the CSP graph one can find two cliques
{x1} and {x2} (i.e., they are not connected), then the sparse
Moment-SOS hierarchy at d  2 would generate two moment
matrices shown in Fig. 5 right. From the color coding in Fig. 5,
we can see that the two smaller moment matrices are principal
submatrices of the big moment matrix. Hence, a 6  6 PSD
constraint is broken into two 3  3 PSD constraints.
It is worth mentioning that (a) while both the dense and the
sparse Moment-SOS hierarchy converge to , they may, and
in general, converge at different speeds; (b) associated with
both (8) and (10) are their dual sums-of-squares (SOS) convex
relaxations (hence the name Moment-SOS hierarchy). Though
we do not explicitly state the SOS relaxations (see  and
references therein), our SPOT package implements them.
C. Term Sparsity
While correlative sparsity (CS) focuses on relationships
between variables, term sparsity (TS) addresses relationships
between monomials. Specifically, TS is designed to partition
monomial bases into blocks according to the monomial con-
nections in the POP . Rather than analyzing general TS
in isolation, we focus on the integration of CS and TS .
Similar to CS, exploiting TS is also related to constructing
a graph called the term sparsity pattern (TSP) graph. This
construction involves three steps: (a) initialization; (b) support
extension; and (c) chordal extension.
We remark that the notion of TS and the construction of the
TSP graph can be less intuitive than the CSP graph mentioned
construction just to understand its high-level idea, and revisit
the math a couple more times later.
Initialization. Let Il, l [p] be the maximal cliques of
(Gcsp), with nl : Il the size of each clique. Let Gl and Hl,
l [p] be defined in the CS grouping procedure and contain
polynomial constraints related to clique Il. The variables x
are grouped into subsets x(I1), . . . , x(Il). Denote A as the
set of all monomials appearing in the POP (2), union with all
even-degree monomials:
supp(gj)
supp(hj) (2N)n (11)
where (2N)n is defined as {2   Nn}.
Support extension. For each l [p] and j {0} Gl,
construct constraint gjs TSP graph Gg
1) Nodes: Vd,l,j : [x(Il)]ddg
j  (these relate to monomials)
2) Edges: Ed,l,j  {(, )  supp(Md(gj, Il),) A  0},
Md(gj, Il),  gj  [x(Il)]ddg
j ()  [x(Il)]ddg
For each each l [p] and j Hl, define the binary mask
vector Bh
supp(Hd(hj, Il)) A
otherwise
Hd(hj, Il)  hj  [x(Il)]().
Chordal extension. For each l [p] and j {0} Gl, let
adjacency matrix, which is naturally a binary mask matrix.
Fig. 6: (a) Gg
We shall illustrate this using our robotics example.
Example 9 (TSP Graph of Example 1). Consider the toy
examples two cliques: I1 : {x0, v0, 1,0, 2,0} and I2 :
{x0, x1, v0} (illustrated in Fig. 4). Define g1 : 1,0  1  x0
and g0 : 1. Then, Gg
There exists an edge between x0 and 1,0 since x0 and
[1, x0, v0, 1,0, 2,0]T, respectively. According to (12),
and 2,0x0 A since 2,0  ( 2,0
edge between x2
0 and x2
1 since x2
1 is of even degree. Both
Note that the crucial difference between CSP and TSP is that
the nodes of a CSP graph are the variables while the nodes
of a TSP graph are monomials. Therefore, while the goal of
CSP is to break the entire variable x into smaller cliques of
basis [x(Il)]d into smaller cliques of monomials.
Combining CS and TS, we can further decompose the PSD
constraints in the sparse Moment-SOS hierarchy (10) into
smaller ones. Due to space constraints, we defer a formal
presentation to Appendix B. The high-level intuition, however,
is that the binary masks obtained from the TSP allow us
to only focus on the entries of the matrix variables in (10)
corresponding to nonzero entries in the masks.
D. Sparse Polynomial Optimization Toolbox (SPOT)
To automate the aforementioned sparsity exploitation, we
develop a new C package SPOT. Compared with the Julia
package TSSOS, SPOT is faster and also provides more op-
tions. (i) SPOT provides both general moment relaxation and
SOS relaxation, which complements TSSOS (only provides
SOS relaxation). (ii) For both CS and TS, SPOT provides four
degree chordal extension (MD); (c) minimum fill chordal
extension (MF); (d) user-defined. (iii) SPOT provides a special
option partial term sparsity, which enables TS only for the
moment matrices and the localizing matrices (i.e., inequality
constraints), while applying CS to equality constraints. This
heuristic approach is motivated by the observation that in SOS
more free variables and does not significantly impact the
solution time of an SDP solver. In many cases, partial TS
yields tighter lower bounds while keeping the computation
time nearly unchanged. (iv) Through our Matlab and Python
CSP and TSP graphs, as shown in Fig. 1. The automatic
sparsity detection pipleline is illustrated in Fig. 7.
III. ROBOTICS-SPECIFIC SPARSITY
While automatic correlative and term sparsity (CS-TS)
exploitation is powerful, it has two notable limitations. (a) It
occasionally fails to capture time, spatial, and kino-dynamical
sparsity inherent in contact-rich planning problems, such as
the Markov property described in . (b) The approach
introduced in II heavily depends on approximate minimal
chordal extensions. Although theoretically rigorous, chordal
extensions can substantially increase the size of variable or
term cliques, resulting in scalability challenges.
To address these, we propose several robotics-specific spar-
sity patterns as auxiliary tools to complement the automatic
sparsity. Similarly, we categorize robotics-specific sparsity
patterns into two levels, (a) variable level and (b) term level.
The semi-automatic robotics-specific sparsity pattern injection
is shown in Fig. 7, marked in red.
A. Variable-level Robotics-Specific Sparsity
Kinematic chain. Numerous robotic systems exhibit chain-
like (or tree-like) mechanical structures, commonly found
in manipulation and locomotion. These structures lead to a
natural separation of kinematic and dynamic variables across
different links. For example, consider the following system:
(x2,k x3,k)2  r2
which can be viewed as a 1-D two-link chain, with three states
(x1, x2, x3) and two geometric constraints in (16d). If only
exploring the Markov property in , a chain of cliques will
be derived, with the kth clique containing 9 variables:
{xi,k, xi,k1, ui,k}3
decompose the clique as three cliques of size 3:
{xi,k, xi,k1, ui,k} , i  1, 2, 3
and four cliques of size 2:
as illustrated in Fig. 8(a). Note that this clique partition cannot
be discovered by the general sparsity pattern introduced in II,
since the graph in Fig. 8(a) is not chordal.
Separation plane. Consider a general obstacle avoidance
a union of convex sets. We denote the decomposition of robot
as {Pi}i[m] and the decomposition of obstacles as {Qj}j[n].
For each i and j, Pi has no collision with Qj if and only if
there exists a plane Hi,j separating Pi and Qj. Consider Pi
and Qj being both 2-D polygons:
is vertices
js vertices
where (Ai,j, Bi,j, Ci,j) determines a 2-D separation plane
(line) Hi,j. For constraints (20), (Ai,j, Bi,j, Ci,j) has no direct
relationship between each other. Thus, in each time step,
instead of defining a large variable clique:
other variables, {(Ai,j, Bi,j, Ci,j)}i[m],j[n]
we define mn smaller variable cliques:
{other variables, (Ai,j, Bi,j, Ci,j)}i[m],j[n]
The resulting clique size is invariant to m and n, as illustrated
in Fig. 8(b). Whats more, one can check that the decomposi-
tion (23) still satisfies the running intersection property (RIP)
required in correlative sparsity pattern .
Variable-level Maximal Cliques
Variable-level Sparsity Graph
Term-level Sparsity Graph
Term-level Maximal Cliques
Fully Automatic
Semi-Automatic
- Kinematic chain sparsity
- Separable contact modes
- Separating hyperplane
Chordal Extension
Chordal Extension
General Polynomial Optimization Problem (POP)
Fig. 7: Overall pipeline of the Sparse Polynomial Optimization Toolbox (SPOT). Blue curves: the automatic detection of
correlative and term sparsity patterns. Red curves: semi-automatic injection of robotics-specific sparsity patterns.
(a) Kinematic chain
(b) Separation plane
(c) Separable contact
Fig. 8: Robotics-specific sparsity patterns.
B. Term-level Robotics-Specific Sparsity
Separable contact modes. Frequently in contact-rich plan-
C2 andC3). It can be modelled as polynomial equalities:
where i is a binary variable corresponding to whether the i-th
contact mode is selected. In variable level, there is no sparsity
in (24), since P
i  1 groups all is together. However,
we show that the sparsity is still rich in the term level. Consider
the generation procedure of A in term sparsity (11), for the
polynomial equality constraint system (24):
Consider the special case n  3 in second-order relaxation
d  2, and there is only one variable clique (i.e., l  1).
By definition of the polynomial multiplier H2(hi, I1), i
{0, 1, 2, 3} for equality constraints (9c):
H2(hi, I1)
If we proceed with the support extension procedure for equal-
ity constraints (13), then we have
In the second-order moment matrix, the unmasked terms are:
leading to the moment matrix generated by a reduced basis:
as shown in Fig. 8(c). The key observation is that there is
no ij(i  j) in the new basis (i.e., the contact modes are
separated). For a general n, the reduced basis is of size 2n1,
which is much smaller than the standard monomial basis of
size (n1)(n2)
Separable contact forces. In contact-implicit formulation,
each possible contact is modelled as a set of complementary
constraints. Suppose there are n contact points, then a typical
dynamics formulation is (cf. C1 and C5):
0 i gi(x) 0, i [n]
fi(i, x, u)  0
where x Rnx is the system state and u Rnu is
the control input. Similar to the contact mode case (24),
i[n] fi(i, x, u) groups all is together. Thus, there is
no variable-level sparsity pattern. However, inspired by the
reduced basis introduced in (33), we can directly write down
an extended reduced basis containing x and u. For simplicity,
assume x and u are both of one dimension, fi is of quadratic
form and linear in i, then the reduced basis is
{i}i[n],{2
i}i[n],{xi}i[n],{ui}i[n]
which grows linearly in n.
Although we introduce these robotics-specific sparsity
patterns in the context of contact-rich motion planning,
manysuch as kinematic-chain structures and supporting-
hyperplane constraintsare generic and apply equally well
to tasks that do not involve contact.
IV. EXPERIMENTS
(sx, sy)
(px, py)
(px, py)
(px, py)
(xl, yl)
(xr, yr)
contact model
self collision
Fig. 9: illustrations of five contact-rich planning tasks. (a) Push
Bot; (b) Push Box; (c) Push T-block; (d) Push Box with a
Tunnel; (e) Planar Hand.
General setup. We consider five contact-rich problems.
1) Push Bot: A cart-pole system between two soft walls,
shown in Fig. 9(a). The objective is to stabilize the cart-
pole at (a, )  (0, ). For polynomial dynamics and
other detailed settings, please refer to Appendix C1.
2) Push Box: A simple pusher-slider system, illustrated in
Fig. 9(b). The goal is to push the box from an initial
configuration (sx, sy, ) to a target configuration. There
are 4 possible contact modes at each time step. Detailed
settings can be found in Appendix C2.
3) Push T-Block: Similar to Push Box, but the box is
replaced with a T-block, resulting in 8 possible contact
modes at each time step, as shown in Fig. 9(c). Please
refer to Appendix C3 for detailed settings.
4) Push Box with a Tunnel: Similar to Push Box, except
that two circular obstacles form a tunnel along the boxs
path to its goal, as shown in Fig. 9(d). Detailed settings
are provided in Appendix C4.
5) Planar Hand: A two-fingered system rotating a 2D disk
in a horizontal plane, as shown in Fig. 9(e). The goal is
to rotate the disk by 360using two fingertip contacts
while minimizing the translation of the disks center of
mass. See Appendix C5 for further details.
for the Push T task. Experiments were performed on a high-
performance workstation equipped with a 2.7 GHz AMD
64-Core sWRX8 Processor and 1 TB of RAM, enabling
MOSEK  to solve large-scale problems utilizing 64 threads.
Conversion speed. We compare SPOT and TSSOS in terms
of conversion time across the five planning problems, consid-
ering different CS and TS options. In all cases, the planning
horizon is set to N  30. For the Push Box with a Tunnel
tighter lower bound, while for the other examples, d is set to 2.
The results are summarized in Table I. SPOT consistently out-
performs TSSOS, achieving at least a 2 speedup. For large-
scale problems such as Push Box with a Tunnel, SPOT achieves
approximately a 5 speedup. For the Planar Hand problem,
the automatic CS pattern generation produces clique sizes
exceeding 20 through both MF and MD methods, resulting in a
large-scale SDP with over 1 million constraints. Since TSSOS
tightly integrates its conversion and SDP solving processes, it
is difficult to isolate the conversion time. Therefore, we only
report SPOTs conversion time for this case, which remains
under 100 seconds despite the problems scale.
Sparsity
Examples
Push Bot
Push Box
Planar Hand
TABLE I: Conversion time comparison between SPOT and
TSSOS across examples, with different CS-TS options.
Self-defined variable cliques. Since the automatic sparsity
exploitation mechanism may fail to detect robotics-specific
1) Generate a general sparsity pattern using SPOT.
2) Manually inspect the variable cliques to determine
whether certain robotics-specific variable-level sparsity
patterns can be incorporated.
3) Modify the generated cliques and resend them to SPOT
using the SELF option.
For example, in the Planar Hand task, leveraging the kine-
matic chain pattern discussed in III, we manually partition
the variables at each time step into 14 smaller cliques, with
sizes ranging from 6 to 14. Due to space constraints, these
cliques are detailed in Appendix D. These manually defined
cliques precisely correspond to the red circles in Fig. 1(a),
illustrating the specific sparsity pattern.
Robust minimizer extraction. Due to the inherent com-
plexity of contact-rich planning problems, it is not uncommon
to encounter two types of relaxation failure cases:
1) The sparse Moment-SOS Hierarchy is not tight.
2) The sparse Moment-SOS Hierarchy is tight but admits
multiple solutions.
In both cases, the moment matrices fail to attain rank 1 (or
other general tightness certificates). To extract minimizers,
TSSOS and  both employ the same naive approach:
obtain the degree-1 submatrix of each moment matrix, then
average the normalized eigenvectors across different variable
cliques. While straightforward to implement, this method
is not robust in practice, often leading to infeasible local
rounding and large suboptimality gaps. On the other hand,
demonstrates that the Gelfand-Naimark-Segal (GNS) construc-
tion provides a robust approach for minimizer extraction from
a single moment matrix. Inspired by this, we propose the
following heuristic algorithm for minimizer extraction in the
presence of multiple moment matrices:
1) For each moment matrix, extract minimizers along with
their associated weights using the GNS construction.
2) Select the minimizer with the highest weight and average
it across different variable cliques.
This seemingly minor modification significantly improves
robustness compared to the naive extraction method. We
implemented the new minimizer extraction scheme in our
SPOT package. A detailed discussion of GNS is beyond the
scope of this paper; we refer interested readers to .
Numerical results. The results are presented in Table II.
The planning horizon N is set to 30. For the Push Bot, Push
states. For the Push Box with a Tunnel and Planar Hand tasks,
we consider 5 random initial states. All reported statistics
represent mean values. From semidefinite relaxation, we can
get a lower bound flower of original nonconvex POP. After
extracting solution, we use an in-house local solver to round a
feasible solution with an upper bound fupper. The suboptimality
gap is defined as:
flower fupper
1  flower  fupper
We also report max KKT residual kkt and MOSEK solving
time. Since SOS relaxation tends to generate much less con-
straint numbers compared to moment relaxation, and MOSEK is
sensitive to constraint numbers, we only test SOS relaxations.
The numerical results reveal a clear trade-off between
computational efficiency and relaxation tightness. When TS
is not enabled, all average suboptimality gaps remain below
scale problems can take up to 5 minutes. Enabling TS with
MF significantly improves computational efficiency. For the
Push Bot, Push Box, and Push T Block tasks, we achieve
near real-time solving speeds. However, this comes at the cost
of significantly larger suboptimality gaps. In all of our case
tasks. Notably, there are two instances where MOSEK fails to
solve the SDP to high accuracy: (a) Push Bot, SELF  MAX;
(b) Planar Hand, SELF  MF. The underlying causes of these
failures remain unknown. We also report the corresponding
SDP constraint number, PSD cone number, and max PSD
cone size in Table III. The demonstration of global optimal
trajectories can be found in Fig. 10.
Real-world Push T-Block validations. We extensively val-
idate our global optimal policy in the real world Push T-Block
accurate pose estimation of the T-block. Due to the global
optimality of our approach, a planning horizon of N  5
is sufficient to generate high-quality planned trajectories. At
each time step, we execute the pushers first action and then
re-plan. The average re-planning time is 3.7 seconds, with CS
set to MF and TS set to NON. We evaluate our framework
in 20 random trials, evenly split between two categories:
clean push-T tasks, which involve standard push-T scenarios
without disturbances, and dirty push-T tasks, where severe
model mismatches and external disturbances are introduced
to assess the planners robustness. These disturbances include
cases where the T-block is wrapped in a cable, put on some
irregular surface, or contained within a small box. These
three scenarios correspond to lines 2-4 in Fig. 1(c). Note
that all these dirty push-T cases make our modeling (which
is very simple) effectively wrong. However, our planner
demonstrates remarkable efficiency and robustness across all
test cases, achieving a 100 success rate while naturally
accommodating a wide range of initial states and challenging
environments. For more demonstrations, please see Fig. 11 and
our attached supplementary materials.
V. CONCLUSION
We introduced a new paradigm to contact-rich motion
planning by exploiting both generic and robotics-specific spar-
sity patterns within semidefinite relaxations. Our method effi-
ciently exploits correlative, term, and robotics-specific sparsity,
enabling near-global optimization of complex robotic motion
planning tasks. Through the Sparse Polynomial Optimization
Toolbox (SPOT), we automated sparsity detection, significantly
reducing computation time while maintaining solution quality.
Extensive experiments, including various real-world push-T
Examples
SELF  NON
SELF  MAX
SELF  MF
log10(kkt)
time (s)
log10(kkt)
time (s)
log10(kkt)
time (s)
Push Bot
Push Box
Planar Hand
TABLE II: Comparison of suboptimality gap g, max KKT residual kkt, and MOSEK solving times for different tasks under
SELF  NON, SELF  MAX, and SELF  MF settings. Throughout the table, we only consider SOS relaxation.
Examples
SELF  NON
SELF  MAX
SELF  MF
Constraint
PSD Cone
Constraint
PSD Cone
Constraint
PSD Cone
Cone Size
Cone Size
Cone Size
Push Bot
Push Box
Planar Hand
TABLE III: Comparison of constraint number, PSD cone number, and max PSD cone size for different tasks under SELF
(a) Push Bot
(b) Push Box
(d) Push Box with a Tunnel
(e) Planar Hand
(c) Push T-Block
Fig. 10: More globally optimal trajectories from SPOT.
Fig. 11: More demonstrations from real-world dirty push-T tasks. From top to bottom: T-block (1) contained in a box; (2)
sits on top of some irregular surfaces; (3) attached to some irregular objects; (4) stacked with another T-block; (5) put on some
irregular objects.
Limitations and future work. Despite its efficiency, our
approach faces challenges in scalability, suboptimality gaps,
and real-time execution. Large-scale problems with many con-
tact modes still pose computational bottlenecks, and automatic
sparsity detection can lead to oversized relaxations. Future
improvements can explore GPU-accelerated first-order SDP
tics to further advance real-time and large-scale applications.
for each problem, but we anticipate that our open-source SPOT
packagedesigned for rapid experimentation with alternative
sparsity structureswill spur the discovery of many more.
REFERENCES
Mosek ApS.
Mosek optimization toolbox for matlab.
Users Guide and Reference Manual, Version, 4(1), 2019.
Alp Aydinoglu and Michael Posa.
Real-time multi-
contact model predictive control via admm.
International Conference on Robotics and Automation
(ICRA), pages 34143
